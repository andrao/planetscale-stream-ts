//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file contains all the types necessary to make
// RPC calls to Vttablet.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file query.proto (package query, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import {
    Message,
    proto3,
    protoInt64,
    type BinaryReadOptions,
    type FieldList,
    type JsonReadOptions,
    type JsonValue,
    type PartialMessage,
    type PlainMessage,
} from '@bufbuild/protobuf';
import { TabletAlias, TabletType } from './topodata_pb.js';
import { CallerID, RPCError } from './vtrpc_pb.js';

/**
 * Flags sent from the MySQL C API
 *
 * @generated from enum query.MySqlFlag
 */
export enum MySqlFlag {
    /**
     * @generated from enum value: EMPTY = 0;
     */
    EMPTY = 0,

    /**
     * @generated from enum value: NOT_NULL_FLAG = 1;
     */
    NOT_NULL_FLAG = 1,

    /**
     * @generated from enum value: PRI_KEY_FLAG = 2;
     */
    PRI_KEY_FLAG = 2,

    /**
     * @generated from enum value: UNIQUE_KEY_FLAG = 4;
     */
    UNIQUE_KEY_FLAG = 4,

    /**
     * @generated from enum value: MULTIPLE_KEY_FLAG = 8;
     */
    MULTIPLE_KEY_FLAG = 8,

    /**
     * @generated from enum value: BLOB_FLAG = 16;
     */
    BLOB_FLAG = 16,

    /**
     * @generated from enum value: UNSIGNED_FLAG = 32;
     */
    UNSIGNED_FLAG = 32,

    /**
     * @generated from enum value: ZEROFILL_FLAG = 64;
     */
    ZEROFILL_FLAG = 64,

    /**
     * @generated from enum value: BINARY_FLAG = 128;
     */
    BINARY_FLAG = 128,

    /**
     * @generated from enum value: ENUM_FLAG = 256;
     */
    ENUM_FLAG = 256,

    /**
     * @generated from enum value: AUTO_INCREMENT_FLAG = 512;
     */
    AUTO_INCREMENT_FLAG = 512,

    /**
     * @generated from enum value: TIMESTAMP_FLAG = 1024;
     */
    TIMESTAMP_FLAG = 1024,

    /**
     * @generated from enum value: SET_FLAG = 2048;
     */
    SET_FLAG = 2048,

    /**
     * @generated from enum value: NO_DEFAULT_VALUE_FLAG = 4096;
     */
    NO_DEFAULT_VALUE_FLAG = 4096,

    /**
     * @generated from enum value: ON_UPDATE_NOW_FLAG = 8192;
     */
    ON_UPDATE_NOW_FLAG = 8192,

    /**
     * @generated from enum value: NUM_FLAG = 32768;
     */
    NUM_FLAG = 32768,

    /**
     * @generated from enum value: PART_KEY_FLAG = 16384;
     */
    PART_KEY_FLAG = 16384,

    /**
     * @generated from enum value: GROUP_FLAG = 32768;
     */
    GROUP_FLAG = 32768,

    /**
     * @generated from enum value: UNIQUE_FLAG = 65536;
     */
    UNIQUE_FLAG = 65536,

    /**
     * @generated from enum value: BINCMP_FLAG = 131072;
     */
    BINCMP_FLAG = 131072,
}
// Retrieve enum metadata with: proto3.getEnumType(MySqlFlag)
proto3.util.setEnumType(MySqlFlag, 'query.MySqlFlag', [
    { no: 0, name: 'EMPTY' },
    { no: 1, name: 'NOT_NULL_FLAG' },
    { no: 2, name: 'PRI_KEY_FLAG' },
    { no: 4, name: 'UNIQUE_KEY_FLAG' },
    { no: 8, name: 'MULTIPLE_KEY_FLAG' },
    { no: 16, name: 'BLOB_FLAG' },
    { no: 32, name: 'UNSIGNED_FLAG' },
    { no: 64, name: 'ZEROFILL_FLAG' },
    { no: 128, name: 'BINARY_FLAG' },
    { no: 256, name: 'ENUM_FLAG' },
    { no: 512, name: 'AUTO_INCREMENT_FLAG' },
    { no: 1024, name: 'TIMESTAMP_FLAG' },
    { no: 2048, name: 'SET_FLAG' },
    { no: 4096, name: 'NO_DEFAULT_VALUE_FLAG' },
    { no: 8192, name: 'ON_UPDATE_NOW_FLAG' },
    { no: 32768, name: 'NUM_FLAG' },
    { no: 16384, name: 'PART_KEY_FLAG' },
    { no: 32768, name: 'GROUP_FLAG' },
    { no: 65536, name: 'UNIQUE_FLAG' },
    { no: 131072, name: 'BINCMP_FLAG' },
]);

/**
 * Flag allows us to qualify types by their common properties.
 *
 * @generated from enum query.Flag
 */
export enum Flag {
    /**
     * @generated from enum value: NONE = 0;
     */
    NONE = 0,

    /**
     * @generated from enum value: ISINTEGRAL = 256;
     */
    ISINTEGRAL = 256,

    /**
     * @generated from enum value: ISUNSIGNED = 512;
     */
    ISUNSIGNED = 512,

    /**
     * @generated from enum value: ISFLOAT = 1024;
     */
    ISFLOAT = 1024,

    /**
     * @generated from enum value: ISQUOTED = 2048;
     */
    ISQUOTED = 2048,

    /**
     * @generated from enum value: ISTEXT = 4096;
     */
    ISTEXT = 4096,

    /**
     * @generated from enum value: ISBINARY = 8192;
     */
    ISBINARY = 8192,
}
// Retrieve enum metadata with: proto3.getEnumType(Flag)
proto3.util.setEnumType(Flag, 'query.Flag', [
    { no: 0, name: 'NONE' },
    { no: 256, name: 'ISINTEGRAL' },
    { no: 512, name: 'ISUNSIGNED' },
    { no: 1024, name: 'ISFLOAT' },
    { no: 2048, name: 'ISQUOTED' },
    { no: 4096, name: 'ISTEXT' },
    { no: 8192, name: 'ISBINARY' },
]);

/**
 * Type defines the various supported data types in bind vars
 * and query results.
 *
 * @generated from enum query.Type
 */
export enum Type {
    /**
     * NULL_TYPE specifies a NULL type.
     *
     * @generated from enum value: NULL_TYPE = 0;
     */
    NULL_TYPE = 0,

    /**
     * INT8 specifies a TINYINT type.
     * Properties: 1, IsNumber.
     *
     * @generated from enum value: INT8 = 257;
     */
    INT8 = 257,

    /**
     * UINT8 specifies a TINYINT UNSIGNED type.
     * Properties: 2, IsNumber, IsUnsigned.
     *
     * @generated from enum value: UINT8 = 770;
     */
    UINT8 = 770,

    /**
     * INT16 specifies a SMALLINT type.
     * Properties: 3, IsNumber.
     *
     * @generated from enum value: INT16 = 259;
     */
    INT16 = 259,

    /**
     * UINT16 specifies a SMALLINT UNSIGNED type.
     * Properties: 4, IsNumber, IsUnsigned.
     *
     * @generated from enum value: UINT16 = 772;
     */
    UINT16 = 772,

    /**
     * INT24 specifies a MEDIUMINT type.
     * Properties: 5, IsNumber.
     *
     * @generated from enum value: INT24 = 261;
     */
    INT24 = 261,

    /**
     * UINT24 specifies a MEDIUMINT UNSIGNED type.
     * Properties: 6, IsNumber, IsUnsigned.
     *
     * @generated from enum value: UINT24 = 774;
     */
    UINT24 = 774,

    /**
     * INT32 specifies a INTEGER type.
     * Properties: 7, IsNumber.
     *
     * @generated from enum value: INT32 = 263;
     */
    INT32 = 263,

    /**
     * UINT32 specifies a INTEGER UNSIGNED type.
     * Properties: 8, IsNumber, IsUnsigned.
     *
     * @generated from enum value: UINT32 = 776;
     */
    UINT32 = 776,

    /**
     * INT64 specifies a BIGINT type.
     * Properties: 9, IsNumber.
     *
     * @generated from enum value: INT64 = 265;
     */
    INT64 = 265,

    /**
     * UINT64 specifies a BIGINT UNSIGNED type.
     * Properties: 10, IsNumber, IsUnsigned.
     *
     * @generated from enum value: UINT64 = 778;
     */
    UINT64 = 778,

    /**
     * FLOAT32 specifies a FLOAT type.
     * Properties: 11, IsFloat.
     *
     * @generated from enum value: FLOAT32 = 1035;
     */
    FLOAT32 = 1035,

    /**
     * FLOAT64 specifies a DOUBLE or REAL type.
     * Properties: 12, IsFloat.
     *
     * @generated from enum value: FLOAT64 = 1036;
     */
    FLOAT64 = 1036,

    /**
     * TIMESTAMP specifies a TIMESTAMP type.
     * Properties: 13, IsQuoted.
     *
     * @generated from enum value: TIMESTAMP = 2061;
     */
    TIMESTAMP = 2061,

    /**
     * DATE specifies a DATE type.
     * Properties: 14, IsQuoted.
     *
     * @generated from enum value: DATE = 2062;
     */
    DATE = 2062,

    /**
     * TIME specifies a TIME type.
     * Properties: 15, IsQuoted.
     *
     * @generated from enum value: TIME = 2063;
     */
    TIME = 2063,

    /**
     * DATETIME specifies a DATETIME type.
     * Properties: 16, IsQuoted.
     *
     * @generated from enum value: DATETIME = 2064;
     */
    DATETIME = 2064,

    /**
     * YEAR specifies a YEAR type.
     * Properties: 17, IsNumber, IsUnsigned.
     *
     * @generated from enum value: YEAR = 785;
     */
    YEAR = 785,

    /**
     * DECIMAL specifies a DECIMAL or NUMERIC type.
     * Properties: 18, None.
     *
     * @generated from enum value: DECIMAL = 18;
     */
    DECIMAL = 18,

    /**
     * TEXT specifies a TEXT type.
     * Properties: 19, IsQuoted, IsText.
     *
     * @generated from enum value: TEXT = 6163;
     */
    TEXT = 6163,

    /**
     * BLOB specifies a BLOB type.
     * Properties: 20, IsQuoted, IsBinary.
     *
     * @generated from enum value: BLOB = 10260;
     */
    BLOB = 10260,

    /**
     * VARCHAR specifies a VARCHAR type.
     * Properties: 21, IsQuoted, IsText.
     *
     * @generated from enum value: VARCHAR = 6165;
     */
    VARCHAR = 6165,

    /**
     * VARBINARY specifies a VARBINARY type.
     * Properties: 22, IsQuoted, IsBinary.
     *
     * @generated from enum value: VARBINARY = 10262;
     */
    VARBINARY = 10262,

    /**
     * CHAR specifies a CHAR type.
     * Properties: 23, IsQuoted, IsText.
     *
     * @generated from enum value: CHAR = 6167;
     */
    CHAR = 6167,

    /**
     * BINARY specifies a BINARY type.
     * Properties: 24, IsQuoted, IsBinary.
     *
     * @generated from enum value: BINARY = 10264;
     */
    BINARY = 10264,

    /**
     * BIT specifies a BIT type.
     * Properties: 25, IsQuoted.
     *
     * @generated from enum value: BIT = 2073;
     */
    BIT = 2073,

    /**
     * ENUM specifies an ENUM type.
     * Properties: 26, IsQuoted.
     *
     * @generated from enum value: ENUM = 2074;
     */
    ENUM = 2074,

    /**
     * SET specifies a SET type.
     * Properties: 27, IsQuoted.
     *
     * @generated from enum value: SET = 2075;
     */
    SET = 2075,

    /**
     * TUPLE specifies a tuple. This cannot
     * be returned in a QueryResult, but it can
     * be sent as a bind var.
     * Properties: 28, None.
     *
     * @generated from enum value: TUPLE = 28;
     */
    TUPLE = 28,

    /**
     * GEOMETRY specifies a GEOMETRY type.
     * Properties: 29, IsQuoted.
     *
     * @generated from enum value: GEOMETRY = 2077;
     */
    GEOMETRY = 2077,

    /**
     * JSON specifies a JSON type.
     * Properties: 30, IsQuoted.
     *
     * @generated from enum value: JSON = 2078;
     */
    JSON = 2078,

    /**
     * EXPRESSION specifies a SQL expression.
     * This type is for internal use only.
     * Properties: 31, None.
     *
     * @generated from enum value: EXPRESSION = 31;
     */
    EXPRESSION = 31,

    /**
     * HEXNUM specifies a HEXNUM type (unquoted varbinary).
     * Properties: 32, IsText.
     *
     * @generated from enum value: HEXNUM = 4128;
     */
    HEXNUM = 4128,

    /**
     * HEXVAL specifies a HEXVAL type (unquoted varbinary).
     * Properties: 33, IsText.
     *
     * @generated from enum value: HEXVAL = 4129;
     */
    HEXVAL = 4129,

    /**
     * BITNUM specifies a base 2 binary type (unquoted varbinary).
     * Properties: 34, IsText.
     *
     * @generated from enum value: BITNUM = 4130;
     */
    BITNUM = 4130,

    /**
     * VECTOR specifies a VECTOR type
     * Properties: 35, IsQuoted.
     *
     * @generated from enum value: VECTOR = 2083;
     */
    VECTOR = 2083,

    /**
     * RAW specifies a type which won't be quoted but the value used as-is while encoding.
     *
     * @generated from enum value: RAW = 2084;
     */
    RAW = 2084,
}
// Retrieve enum metadata with: proto3.getEnumType(Type)
proto3.util.setEnumType(Type, 'query.Type', [
    { no: 0, name: 'NULL_TYPE' },
    { no: 257, name: 'INT8' },
    { no: 770, name: 'UINT8' },
    { no: 259, name: 'INT16' },
    { no: 772, name: 'UINT16' },
    { no: 261, name: 'INT24' },
    { no: 774, name: 'UINT24' },
    { no: 263, name: 'INT32' },
    { no: 776, name: 'UINT32' },
    { no: 265, name: 'INT64' },
    { no: 778, name: 'UINT64' },
    { no: 1035, name: 'FLOAT32' },
    { no: 1036, name: 'FLOAT64' },
    { no: 2061, name: 'TIMESTAMP' },
    { no: 2062, name: 'DATE' },
    { no: 2063, name: 'TIME' },
    { no: 2064, name: 'DATETIME' },
    { no: 785, name: 'YEAR' },
    { no: 18, name: 'DECIMAL' },
    { no: 6163, name: 'TEXT' },
    { no: 10260, name: 'BLOB' },
    { no: 6165, name: 'VARCHAR' },
    { no: 10262, name: 'VARBINARY' },
    { no: 6167, name: 'CHAR' },
    { no: 10264, name: 'BINARY' },
    { no: 2073, name: 'BIT' },
    { no: 2074, name: 'ENUM' },
    { no: 2075, name: 'SET' },
    { no: 28, name: 'TUPLE' },
    { no: 2077, name: 'GEOMETRY' },
    { no: 2078, name: 'JSON' },
    { no: 31, name: 'EXPRESSION' },
    { no: 4128, name: 'HEXNUM' },
    { no: 4129, name: 'HEXVAL' },
    { no: 4130, name: 'BITNUM' },
    { no: 2083, name: 'VECTOR' },
    { no: 2084, name: 'RAW' },
]);

/**
 * TransactionState represents the state of a distributed transaction.
 *
 * @generated from enum query.TransactionState
 */
export enum TransactionState {
    /**
     * @generated from enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,

    /**
     * @generated from enum value: PREPARE = 1;
     */
    PREPARE = 1,

    /**
     * @generated from enum value: ROLLBACK = 2;
     */
    ROLLBACK = 2,

    /**
     * @generated from enum value: COMMIT = 3;
     */
    COMMIT = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(TransactionState)
proto3.util.setEnumType(TransactionState, 'query.TransactionState', [
    { no: 0, name: 'UNKNOWN' },
    { no: 1, name: 'PREPARE' },
    { no: 2, name: 'ROLLBACK' },
    { no: 3, name: 'COMMIT' },
]);

/**
 * SchemaTableType represents the type of table requested.
 *
 * @generated from enum query.SchemaTableType
 */
export enum SchemaTableType {
    /**
     * @generated from enum value: VIEWS = 0;
     */
    VIEWS = 0,

    /**
     * @generated from enum value: TABLES = 1;
     */
    TABLES = 1,

    /**
     * @generated from enum value: ALL = 2;
     */
    ALL = 2,

    /**
     * @generated from enum value: UDFS = 3;
     */
    UDFS = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SchemaTableType)
proto3.util.setEnumType(SchemaTableType, 'query.SchemaTableType', [
    { no: 0, name: 'VIEWS' },
    { no: 1, name: 'TABLES' },
    { no: 2, name: 'ALL' },
    { no: 3, name: 'UDFS' },
]);

/**
 * Target describes what the client expects the tablet is.
 * If the tablet does not match, an error is returned.
 *
 * @generated from message query.Target
 */
export class Target extends Message<Target> {
    /**
     * @generated from field: string keyspace = 1;
     */
    keyspace = '';

    /**
     * @generated from field: string shard = 2;
     */
    shard = '';

    /**
     * @generated from field: topodata.TabletType tablet_type = 3;
     */
    tabletType = TabletType.UNKNOWN;

    /**
     * cell is used for routing queries between vtgate and vttablets. It
     * is not used when Target is part of the Session sent by the client.
     *
     * @generated from field: string cell = 4;
     */
    cell = '';

    constructor(data?: PartialMessage<Target>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.Target';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'keyspace', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'shard', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 3, name: 'tablet_type', kind: 'enum', T: proto3.getEnumType(TabletType) },
        { no: 4, name: 'cell', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Target {
        return new Target().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Target {
        return new Target().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Target {
        return new Target().fromJsonString(jsonString, options);
    }

    static equals(
        a: Target | PlainMessage<Target> | undefined,
        b: Target | PlainMessage<Target> | undefined,
    ): boolean {
        return proto3.util.equals(Target, a, b);
    }
}

/**
 * VTGateCallerID is sent by VTGate to VTTablet to describe the
 * caller. If possible, this information is secure. For instance,
 * if using unique certificates that guarantee that VTGate->VTTablet
 * traffic cannot be spoofed, then VTTablet can trust this information,
 * and VTTablet will use it for tablet ACLs, for instance.
 * Because of this security guarantee, this is different than the CallerID
 * structure, which is not secure at all, because it is provided
 * by the Vitess client.
 *
 * @generated from message query.VTGateCallerID
 */
export class VTGateCallerID extends Message<VTGateCallerID> {
    /**
     * @generated from field: string username = 1;
     */
    username = '';

    /**
     * @generated from field: repeated string groups = 2;
     */
    groups: string[] = [];

    constructor(data?: PartialMessage<VTGateCallerID>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.VTGateCallerID';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'username', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'groups', kind: 'scalar', T: 9 /* ScalarType.STRING */, repeated: true },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VTGateCallerID {
        return new VTGateCallerID().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VTGateCallerID {
        return new VTGateCallerID().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VTGateCallerID {
        return new VTGateCallerID().fromJsonString(jsonString, options);
    }

    static equals(
        a: VTGateCallerID | PlainMessage<VTGateCallerID> | undefined,
        b: VTGateCallerID | PlainMessage<VTGateCallerID> | undefined,
    ): boolean {
        return proto3.util.equals(VTGateCallerID, a, b);
    }
}

/**
 * EventToken is a structure that describes a point in time in a
 * replication stream on one shard. The most recent known replication
 * position can be retrieved from vttablet when executing a query. It
 * is also sent with the replication streams from the binlog service.
 *
 * @generated from message query.EventToken
 */
export class EventToken extends Message<EventToken> {
    /**
     * timestamp is the MySQL timestamp of the statements. Seconds since Epoch.
     *
     * @generated from field: int64 timestamp = 1;
     */
    timestamp = protoInt64.zero;

    /**
     * The shard name that applied the statements. Note this is not set when
     * streaming from a vttablet. It is only used on the client -> vtgate link.
     *
     * @generated from field: string shard = 2;
     */
    shard = '';

    /**
     * The position on the replication stream after this statement was applied.
     * It is not the transaction ID / GTID, but the position / GTIDSet.
     *
     * @generated from field: string position = 3;
     */
    position = '';

    constructor(data?: PartialMessage<EventToken>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.EventToken';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'timestamp', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 2, name: 'shard', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 3, name: 'position', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EventToken {
        return new EventToken().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EventToken {
        return new EventToken().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EventToken {
        return new EventToken().fromJsonString(jsonString, options);
    }

    static equals(
        a: EventToken | PlainMessage<EventToken> | undefined,
        b: EventToken | PlainMessage<EventToken> | undefined,
    ): boolean {
        return proto3.util.equals(EventToken, a, b);
    }
}

/**
 * Value represents a typed value.
 *
 * @generated from message query.Value
 */
export class Value extends Message<Value> {
    /**
     * @generated from field: query.Type type = 1;
     */
    type = Type.NULL_TYPE;

    /**
     * @generated from field: bytes value = 2;
     */
    value = new Uint8Array(0);

    constructor(data?: PartialMessage<Value>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.Value';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'type', kind: 'enum', T: proto3.getEnumType(Type) },
        { no: 2, name: 'value', kind: 'scalar', T: 12 /* ScalarType.BYTES */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Value {
        return new Value().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Value {
        return new Value().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Value {
        return new Value().fromJsonString(jsonString, options);
    }

    static equals(
        a: Value | PlainMessage<Value> | undefined,
        b: Value | PlainMessage<Value> | undefined,
    ): boolean {
        return proto3.util.equals(Value, a, b);
    }
}

/**
 * BindVariable represents a single bind variable in a Query.
 *
 * @generated from message query.BindVariable
 */
export class BindVariable extends Message<BindVariable> {
    /**
     * @generated from field: query.Type type = 1;
     */
    type = Type.NULL_TYPE;

    /**
     * @generated from field: bytes value = 2;
     */
    value = new Uint8Array(0);

    /**
     * values are set if type is TUPLE.
     *
     * @generated from field: repeated query.Value values = 3;
     */
    values: Value[] = [];

    constructor(data?: PartialMessage<BindVariable>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.BindVariable';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'type', kind: 'enum', T: proto3.getEnumType(Type) },
        { no: 2, name: 'value', kind: 'scalar', T: 12 /* ScalarType.BYTES */ },
        { no: 3, name: 'values', kind: 'message', T: Value, repeated: true },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BindVariable {
        return new BindVariable().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BindVariable {
        return new BindVariable().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BindVariable {
        return new BindVariable().fromJsonString(jsonString, options);
    }

    static equals(
        a: BindVariable | PlainMessage<BindVariable> | undefined,
        b: BindVariable | PlainMessage<BindVariable> | undefined,
    ): boolean {
        return proto3.util.equals(BindVariable, a, b);
    }
}

/**
 * BoundQuery is a query with its bind variables
 *
 * @generated from message query.BoundQuery
 */
export class BoundQuery extends Message<BoundQuery> {
    /**
     * sql is the SQL query to execute
     *
     * @generated from field: string sql = 1;
     */
    sql = '';

    /**
     * bind_variables is a map of all bind variables to expand in the query.
     * nil values are not allowed. Use NULL_TYPE to express a NULL value.
     *
     * @generated from field: map<string, query.BindVariable> bind_variables = 2;
     */
    bindVariables: { [key: string]: BindVariable } = {};

    constructor(data?: PartialMessage<BoundQuery>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.BoundQuery';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'sql', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        {
            no: 2,
            name: 'bind_variables',
            kind: 'map',
            K: 9 /* ScalarType.STRING */,
            V: { kind: 'message', T: BindVariable },
        },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BoundQuery {
        return new BoundQuery().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BoundQuery {
        return new BoundQuery().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BoundQuery {
        return new BoundQuery().fromJsonString(jsonString, options);
    }

    static equals(
        a: BoundQuery | PlainMessage<BoundQuery> | undefined,
        b: BoundQuery | PlainMessage<BoundQuery> | undefined,
    ): boolean {
        return proto3.util.equals(BoundQuery, a, b);
    }
}

/**
 * ExecuteOptions is passed around for all Execute calls.
 *
 * @generated from message query.ExecuteOptions
 */
export class ExecuteOptions extends Message<ExecuteOptions> {
    /**
     * Controls what fields are returned in Field message responses from mysql, i.e.
     * field name, table name, etc. This is an optimization for high-QPS queries where
     * the client knows what it's getting
     *
     * @generated from field: query.ExecuteOptions.IncludedFields included_fields = 4;
     */
    includedFields = ExecuteOptions_IncludedFields.TYPE_AND_NAME;

    /**
     * client_rows_found specifies if rows_affected should return
     * rows found instead of rows affected. Behavior is defined
     * by MySQL's CLIENT_FOUND_ROWS flag.
     *
     * @generated from field: bool client_found_rows = 5;
     */
    clientFoundRows = false;

    /**
     * workload specifies the type of workload:
     * OLTP: DMLs allowed, results have row count limit, and
     * query timeouts are shorter.
     * OLAP: DMLS not allowed, no limit on row count, timeouts
     * can be as high as desired.
     * DBA: no limit on rowcount or timeout, all queries allowed
     * but intended for long DMLs and DDLs.
     *
     * @generated from field: query.ExecuteOptions.Workload workload = 6;
     */
    workload = ExecuteOptions_Workload.UNSPECIFIED;

    /**
     * sql_select_limit sets an implicit limit on all select statements. Since
     * vitess also sets a rowcount limit on queries, the smallest value wins.
     *
     * @generated from field: int64 sql_select_limit = 8;
     */
    sqlSelectLimit = protoInt64.zero;

    /**
     * @generated from field: query.ExecuteOptions.TransactionIsolation transaction_isolation = 9;
     */
    transactionIsolation = ExecuteOptions_TransactionIsolation.DEFAULT;

    /**
     * skip_query_plan_cache specifies if the query plan should be cached by vitess.
     * By default all query plans are cached.
     *
     * @generated from field: bool skip_query_plan_cache = 10;
     */
    skipQueryPlanCache = false;

    /**
     * PlannerVersion specifies which planner to use.
     * If DEFAULT is chosen, whatever vtgate was started with will be used
     *
     * @generated from field: query.ExecuteOptions.PlannerVersion planner_version = 11;
     */
    plannerVersion = ExecuteOptions_PlannerVersion.DEFAULT_PLANNER;

    /**
     * has_created_temp_tables signals whether plans created in this session should be cached or not
     * if the user has created temp tables, Vitess will not reuse plans created for this session in other sessions.
     * The current session can still use other sessions cached plans.
     *
     * @generated from field: bool has_created_temp_tables = 12;
     */
    hasCreatedTempTables = false;

    /**
     * @generated from field: query.ExecuteOptions.Consolidator consolidator = 13;
     */
    consolidator = ExecuteOptions_Consolidator.UNSPECIFIED;

    /**
     * TransactionAccessMode specifies the access modes to be used while starting the transaction i.e. READ WRITE/READ ONLY/WITH CONSISTENT SNAPSHOT
     * If not specified, the transaction will be started with the default access mode on the connection.
     *
     * @generated from field: repeated query.ExecuteOptions.TransactionAccessMode transaction_access_mode = 14;
     */
    transactionAccessMode: ExecuteOptions_TransactionAccessMode[] = [];

    /**
     * WorkloadName specifies the name of the workload as indicated in query directives. This is used for instrumentation
     * in metrics and tracing spans.
     *
     * @generated from field: string WorkloadName = 15;
     */
    WorkloadName = '';

    /**
     * priority specifies the priority of the query, between 0 and 100. This is leveraged by the transaction
     * throttler to determine whether, under resource contention, a query should or should not be throttled.
     *
     * @generated from field: string priority = 16;
     */
    priority = '';

    /**
     * timeout specifies the query timeout in milliseconds. If not set, the default timeout is used.
     *
     * @generated from oneof query.ExecuteOptions.timeout
     */
    timeout:
        | {
              /**
               * @generated from field: int64 authoritative_timeout = 17;
               */
              value: bigint;
              case: 'authoritativeTimeout';
          }
        | { case: undefined; value?: undefined } = { case: undefined };

    constructor(data?: PartialMessage<ExecuteOptions>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.ExecuteOptions';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        {
            no: 4,
            name: 'included_fields',
            kind: 'enum',
            T: proto3.getEnumType(ExecuteOptions_IncludedFields),
        },
        { no: 5, name: 'client_found_rows', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        { no: 6, name: 'workload', kind: 'enum', T: proto3.getEnumType(ExecuteOptions_Workload) },
        { no: 8, name: 'sql_select_limit', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        {
            no: 9,
            name: 'transaction_isolation',
            kind: 'enum',
            T: proto3.getEnumType(ExecuteOptions_TransactionIsolation),
        },
        { no: 10, name: 'skip_query_plan_cache', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        {
            no: 11,
            name: 'planner_version',
            kind: 'enum',
            T: proto3.getEnumType(ExecuteOptions_PlannerVersion),
        },
        { no: 12, name: 'has_created_temp_tables', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        {
            no: 13,
            name: 'consolidator',
            kind: 'enum',
            T: proto3.getEnumType(ExecuteOptions_Consolidator),
        },
        {
            no: 14,
            name: 'transaction_access_mode',
            kind: 'enum',
            T: proto3.getEnumType(ExecuteOptions_TransactionAccessMode),
            repeated: true,
        },
        { no: 15, name: 'WorkloadName', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 16, name: 'priority', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        {
            no: 17,
            name: 'authoritative_timeout',
            kind: 'scalar',
            T: 3 /* ScalarType.INT64 */,
            oneof: 'timeout',
        },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteOptions {
        return new ExecuteOptions().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteOptions {
        return new ExecuteOptions().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteOptions {
        return new ExecuteOptions().fromJsonString(jsonString, options);
    }

    static equals(
        a: ExecuteOptions | PlainMessage<ExecuteOptions> | undefined,
        b: ExecuteOptions | PlainMessage<ExecuteOptions> | undefined,
    ): boolean {
        return proto3.util.equals(ExecuteOptions, a, b);
    }
}

/**
 * @generated from enum query.ExecuteOptions.IncludedFields
 */
export enum ExecuteOptions_IncludedFields {
    /**
     * @generated from enum value: TYPE_AND_NAME = 0;
     */
    TYPE_AND_NAME = 0,

    /**
     * @generated from enum value: TYPE_ONLY = 1;
     */
    TYPE_ONLY = 1,

    /**
     * @generated from enum value: ALL = 2;
     */
    ALL = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ExecuteOptions_IncludedFields)
proto3.util.setEnumType(ExecuteOptions_IncludedFields, 'query.ExecuteOptions.IncludedFields', [
    { no: 0, name: 'TYPE_AND_NAME' },
    { no: 1, name: 'TYPE_ONLY' },
    { no: 2, name: 'ALL' },
]);

/**
 * @generated from enum query.ExecuteOptions.Workload
 */
export enum ExecuteOptions_Workload {
    /**
     * @generated from enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,

    /**
     * @generated from enum value: OLTP = 1;
     */
    OLTP = 1,

    /**
     * @generated from enum value: OLAP = 2;
     */
    OLAP = 2,

    /**
     * @generated from enum value: DBA = 3;
     */
    DBA = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ExecuteOptions_Workload)
proto3.util.setEnumType(ExecuteOptions_Workload, 'query.ExecuteOptions.Workload', [
    { no: 0, name: 'UNSPECIFIED' },
    { no: 1, name: 'OLTP' },
    { no: 2, name: 'OLAP' },
    { no: 3, name: 'DBA' },
]);

/**
 * @generated from enum query.ExecuteOptions.TransactionIsolation
 */
export enum ExecuteOptions_TransactionIsolation {
    /**
     * @generated from enum value: DEFAULT = 0;
     */
    DEFAULT = 0,

    /**
     * @generated from enum value: REPEATABLE_READ = 1;
     */
    REPEATABLE_READ = 1,

    /**
     * @generated from enum value: READ_COMMITTED = 2;
     */
    READ_COMMITTED = 2,

    /**
     * @generated from enum value: READ_UNCOMMITTED = 3;
     */
    READ_UNCOMMITTED = 3,

    /**
     * @generated from enum value: SERIALIZABLE = 4;
     */
    SERIALIZABLE = 4,

    /**
     * This is not an "official" transaction level but it will do a
     * START TRANSACTION WITH CONSISTENT SNAPSHOT, READ ONLY
     *
     * @generated from enum value: CONSISTENT_SNAPSHOT_READ_ONLY = 5;
     */
    CONSISTENT_SNAPSHOT_READ_ONLY = 5,

    /**
     * This not an "official" transaction level, it will send queries to mysql
     * without wrapping them in a transaction
     *
     * @generated from enum value: AUTOCOMMIT = 6;
     */
    AUTOCOMMIT = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(ExecuteOptions_TransactionIsolation)
proto3.util.setEnumType(
    ExecuteOptions_TransactionIsolation,
    'query.ExecuteOptions.TransactionIsolation',
    [
        { no: 0, name: 'DEFAULT' },
        { no: 1, name: 'REPEATABLE_READ' },
        { no: 2, name: 'READ_COMMITTED' },
        { no: 3, name: 'READ_UNCOMMITTED' },
        { no: 4, name: 'SERIALIZABLE' },
        { no: 5, name: 'CONSISTENT_SNAPSHOT_READ_ONLY' },
        { no: 6, name: 'AUTOCOMMIT' },
    ],
);

/**
 * @generated from enum query.ExecuteOptions.PlannerVersion
 */
export enum ExecuteOptions_PlannerVersion {
    /**
     * @generated from enum value: DEFAULT_PLANNER = 0;
     */
    DEFAULT_PLANNER = 0,

    /**
     * @generated from enum value: V3 = 1;
     */
    V3 = 1,

    /**
     * @generated from enum value: Gen4 = 2;
     */
    Gen4 = 2,

    /**
     * @generated from enum value: Gen4Greedy = 3;
     */
    Gen4Greedy = 3,

    /**
     * @generated from enum value: Gen4Left2Right = 4;
     */
    Gen4Left2Right = 4,

    /**
     * @generated from enum value: Gen4WithFallback = 5;
     */
    Gen4WithFallback = 5,

    /**
     * @generated from enum value: Gen4CompareV3 = 6;
     */
    Gen4CompareV3 = 6,

    /**
     * @generated from enum value: V3Insert = 7;
     */
    V3Insert = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(ExecuteOptions_PlannerVersion)
proto3.util.setEnumType(ExecuteOptions_PlannerVersion, 'query.ExecuteOptions.PlannerVersion', [
    { no: 0, name: 'DEFAULT_PLANNER' },
    { no: 1, name: 'V3' },
    { no: 2, name: 'Gen4' },
    { no: 3, name: 'Gen4Greedy' },
    { no: 4, name: 'Gen4Left2Right' },
    { no: 5, name: 'Gen4WithFallback' },
    { no: 6, name: 'Gen4CompareV3' },
    { no: 7, name: 'V3Insert' },
]);

/**
 * @generated from enum query.ExecuteOptions.Consolidator
 */
export enum ExecuteOptions_Consolidator {
    /**
     * @generated from enum value: CONSOLIDATOR_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,

    /**
     * @generated from enum value: CONSOLIDATOR_DISABLED = 1;
     */
    DISABLED = 1,

    /**
     * @generated from enum value: CONSOLIDATOR_ENABLED = 2;
     */
    ENABLED = 2,

    /**
     * @generated from enum value: CONSOLIDATOR_ENABLED_REPLICAS = 3;
     */
    ENABLED_REPLICAS = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ExecuteOptions_Consolidator)
proto3.util.setEnumType(ExecuteOptions_Consolidator, 'query.ExecuteOptions.Consolidator', [
    { no: 0, name: 'CONSOLIDATOR_UNSPECIFIED' },
    { no: 1, name: 'CONSOLIDATOR_DISABLED' },
    { no: 2, name: 'CONSOLIDATOR_ENABLED' },
    { no: 3, name: 'CONSOLIDATOR_ENABLED_REPLICAS' },
]);

/**
 * @generated from enum query.ExecuteOptions.TransactionAccessMode
 */
export enum ExecuteOptions_TransactionAccessMode {
    /**
     * @generated from enum value: CONSISTENT_SNAPSHOT = 0;
     */
    CONSISTENT_SNAPSHOT = 0,

    /**
     * @generated from enum value: READ_WRITE = 1;
     */
    READ_WRITE = 1,

    /**
     * @generated from enum value: READ_ONLY = 2;
     */
    READ_ONLY = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ExecuteOptions_TransactionAccessMode)
proto3.util.setEnumType(
    ExecuteOptions_TransactionAccessMode,
    'query.ExecuteOptions.TransactionAccessMode',
    [
        { no: 0, name: 'CONSISTENT_SNAPSHOT' },
        { no: 1, name: 'READ_WRITE' },
        { no: 2, name: 'READ_ONLY' },
    ],
);

/**
 * Field describes a single column returned by a query
 *
 * @generated from message query.Field
 */
export class Field extends Message<Field> {
    /**
     * name of the field as returned by mysql C API
     *
     * @generated from field: string name = 1;
     */
    name = '';

    /**
     * vitess-defined type. Conversion function is in sqltypes package.
     *
     * @generated from field: query.Type type = 2;
     */
    type = Type.NULL_TYPE;

    /**
     * Remaining fields from mysql C API.
     * These fields are only populated when ExecuteOptions.included_fields
     * is set to IncludedFields.ALL.
     *
     * @generated from field: string table = 3;
     */
    table = '';

    /**
     * @generated from field: string org_table = 4;
     */
    orgTable = '';

    /**
     * @generated from field: string database = 5;
     */
    database = '';

    /**
     * @generated from field: string org_name = 6;
     */
    orgName = '';

    /**
     * column_length is really a uint32. All 32 bits can be used.
     *
     * @generated from field: uint32 column_length = 7;
     */
    columnLength = 0;

    /**
     * charset is actually a uint16. Only the lower 16 bits are used.
     *
     * @generated from field: uint32 charset = 8;
     */
    charset = 0;

    /**
     * decimals is actually a uint8. Only the lower 8 bits are used.
     *
     * @generated from field: uint32 decimals = 9;
     */
    decimals = 0;

    /**
     * flags is actually a uint16. Only the lower 16 bits are used.
     *
     * @generated from field: uint32 flags = 10;
     */
    flags = 0;

    /**
     * column_type is optionally populated from information_schema.columns
     *
     * @generated from field: string column_type = 11;
     */
    columnType = '';

    constructor(data?: PartialMessage<Field>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.Field';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'type', kind: 'enum', T: proto3.getEnumType(Type) },
        { no: 3, name: 'table', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 4, name: 'org_table', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 5, name: 'database', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 6, name: 'org_name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 7, name: 'column_length', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
        { no: 8, name: 'charset', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
        { no: 9, name: 'decimals', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
        { no: 10, name: 'flags', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
        { no: 11, name: 'column_type', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Field {
        return new Field().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Field {
        return new Field().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Field {
        return new Field().fromJsonString(jsonString, options);
    }

    static equals(
        a: Field | PlainMessage<Field> | undefined,
        b: Field | PlainMessage<Field> | undefined,
    ): boolean {
        return proto3.util.equals(Field, a, b);
    }
}

/**
 * Row is a database row.
 *
 * @generated from message query.Row
 */
export class Row extends Message<Row> {
    /**
     * lengths contains the length of each value in values.
     * A length of -1 means that the field is NULL. While
     * reading values, you have to accummulate the length
     * to know the offset where the next value begins in values.
     *
     * @generated from field: repeated sint64 lengths = 1;
     */
    lengths: bigint[] = [];

    /**
     * values contains a concatenation of all values in the row.
     *
     * @generated from field: bytes values = 2;
     */
    values = new Uint8Array(0);

    constructor(data?: PartialMessage<Row>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.Row';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'lengths', kind: 'scalar', T: 18 /* ScalarType.SINT64 */, repeated: true },
        { no: 2, name: 'values', kind: 'scalar', T: 12 /* ScalarType.BYTES */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Row {
        return new Row().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Row {
        return new Row().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Row {
        return new Row().fromJsonString(jsonString, options);
    }

    static equals(
        a: Row | PlainMessage<Row> | undefined,
        b: Row | PlainMessage<Row> | undefined,
    ): boolean {
        return proto3.util.equals(Row, a, b);
    }
}

/**
 * QueryResult is returned by Execute and ExecuteStream.
 *
 * As returned by Execute, len(fields) is always equal to len(row)
 * (for each row in rows).
 *
 * As returned by StreamExecute, the first QueryResult has the fields
 * set, and subsequent QueryResult have rows set. And as Execute,
 * len(QueryResult[0].fields) is always equal to len(row) (for each
 * row in rows for each QueryResult in QueryResult[1:]).
 *
 * @generated from message query.QueryResult
 */
export class QueryResult extends Message<QueryResult> {
    /**
     * @generated from field: repeated query.Field fields = 1;
     */
    fields: Field[] = [];

    /**
     * @generated from field: uint64 rows_affected = 2;
     */
    rowsAffected = protoInt64.zero;

    /**
     * @generated from field: uint64 insert_id = 3;
     */
    insertId = protoInt64.zero;

    /**
     * @generated from field: repeated query.Row rows = 4;
     */
    rows: Row[] = [];

    /**
     * @generated from field: string info = 6;
     */
    info = '';

    /**
     * @generated from field: string session_state_changes = 7;
     */
    sessionStateChanges = '';

    constructor(data?: PartialMessage<QueryResult>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.QueryResult';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'fields', kind: 'message', T: Field, repeated: true },
        { no: 2, name: 'rows_affected', kind: 'scalar', T: 4 /* ScalarType.UINT64 */ },
        { no: 3, name: 'insert_id', kind: 'scalar', T: 4 /* ScalarType.UINT64 */ },
        { no: 4, name: 'rows', kind: 'message', T: Row, repeated: true },
        { no: 6, name: 'info', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 7, name: 'session_state_changes', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryResult {
        return new QueryResult().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryResult {
        return new QueryResult().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryResult {
        return new QueryResult().fromJsonString(jsonString, options);
    }

    static equals(
        a: QueryResult | PlainMessage<QueryResult> | undefined,
        b: QueryResult | PlainMessage<QueryResult> | undefined,
    ): boolean {
        return proto3.util.equals(QueryResult, a, b);
    }
}

/**
 * QueryWarning is used to convey out of band query execution warnings
 * by storing in the vtgate.Session
 *
 * @generated from message query.QueryWarning
 */
export class QueryWarning extends Message<QueryWarning> {
    /**
     * @generated from field: uint32 code = 1;
     */
    code = 0;

    /**
     * @generated from field: string message = 2;
     */
    message = '';

    constructor(data?: PartialMessage<QueryWarning>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.QueryWarning';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'code', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
        { no: 2, name: 'message', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryWarning {
        return new QueryWarning().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryWarning {
        return new QueryWarning().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryWarning {
        return new QueryWarning().fromJsonString(jsonString, options);
    }

    static equals(
        a: QueryWarning | PlainMessage<QueryWarning> | undefined,
        b: QueryWarning | PlainMessage<QueryWarning> | undefined,
    ): boolean {
        return proto3.util.equals(QueryWarning, a, b);
    }
}

/**
 * StreamEvent describes a set of transformations that happened as a
 * single transactional unit on a server. It is streamed back by the
 * Update Stream calls.
 *
 * @generated from message query.StreamEvent
 */
export class StreamEvent extends Message<StreamEvent> {
    /**
     * The statements in this transaction.
     *
     * @generated from field: repeated query.StreamEvent.Statement statements = 1;
     */
    statements: StreamEvent_Statement[] = [];

    /**
     * The Event Token for this event.
     *
     * @generated from field: query.EventToken event_token = 2;
     */
    eventToken?: EventToken;

    constructor(data?: PartialMessage<StreamEvent>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.StreamEvent';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'statements', kind: 'message', T: StreamEvent_Statement, repeated: true },
        { no: 2, name: 'event_token', kind: 'message', T: EventToken },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamEvent {
        return new StreamEvent().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamEvent {
        return new StreamEvent().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamEvent {
        return new StreamEvent().fromJsonString(jsonString, options);
    }

    static equals(
        a: StreamEvent | PlainMessage<StreamEvent> | undefined,
        b: StreamEvent | PlainMessage<StreamEvent> | undefined,
    ): boolean {
        return proto3.util.equals(StreamEvent, a, b);
    }
}

/**
 * One individual Statement in a transaction.
 *
 * @generated from message query.StreamEvent.Statement
 */
export class StreamEvent_Statement extends Message<StreamEvent_Statement> {
    /**
     * @generated from field: query.StreamEvent.Statement.Category category = 1;
     */
    category = StreamEvent_Statement_Category.Error;

    /**
     * table_name, primary_key_fields and primary_key_values are set for DML.
     *
     * @generated from field: string table_name = 2;
     */
    tableName = '';

    /**
     * @generated from field: repeated query.Field primary_key_fields = 3;
     */
    primaryKeyFields: Field[] = [];

    /**
     * @generated from field: repeated query.Row primary_key_values = 4;
     */
    primaryKeyValues: Row[] = [];

    /**
     * sql is set for all queries.
     * FIXME(alainjobart) we may not need it for DMLs.
     *
     * @generated from field: bytes sql = 5;
     */
    sql = new Uint8Array(0);

    constructor(data?: PartialMessage<StreamEvent_Statement>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.StreamEvent.Statement';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        {
            no: 1,
            name: 'category',
            kind: 'enum',
            T: proto3.getEnumType(StreamEvent_Statement_Category),
        },
        { no: 2, name: 'table_name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 3, name: 'primary_key_fields', kind: 'message', T: Field, repeated: true },
        { no: 4, name: 'primary_key_values', kind: 'message', T: Row, repeated: true },
        { no: 5, name: 'sql', kind: 'scalar', T: 12 /* ScalarType.BYTES */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): StreamEvent_Statement {
        return new StreamEvent_Statement().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): StreamEvent_Statement {
        return new StreamEvent_Statement().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): StreamEvent_Statement {
        return new StreamEvent_Statement().fromJsonString(jsonString, options);
    }

    static equals(
        a: StreamEvent_Statement | PlainMessage<StreamEvent_Statement> | undefined,
        b: StreamEvent_Statement | PlainMessage<StreamEvent_Statement> | undefined,
    ): boolean {
        return proto3.util.equals(StreamEvent_Statement, a, b);
    }
}

/**
 * The category of one statement.
 *
 * @generated from enum query.StreamEvent.Statement.Category
 */
export enum StreamEvent_Statement_Category {
    /**
     * @generated from enum value: Error = 0;
     */
    Error = 0,

    /**
     * @generated from enum value: DML = 1;
     */
    DML = 1,

    /**
     * @generated from enum value: DDL = 2;
     */
    DDL = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(StreamEvent_Statement_Category)
proto3.util.setEnumType(StreamEvent_Statement_Category, 'query.StreamEvent.Statement.Category', [
    { no: 0, name: 'Error' },
    { no: 1, name: 'DML' },
    { no: 2, name: 'DDL' },
]);

/**
 * ExecuteRequest is the payload to Execute
 *
 * @generated from message query.ExecuteRequest
 */
export class ExecuteRequest extends Message<ExecuteRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: query.BoundQuery query = 4;
     */
    query?: BoundQuery;

    /**
     * @generated from field: int64 transaction_id = 5;
     */
    transactionId = protoInt64.zero;

    /**
     * @generated from field: query.ExecuteOptions options = 6;
     */
    options?: ExecuteOptions;

    /**
     * @generated from field: int64 reserved_id = 7;
     */
    reservedId = protoInt64.zero;

    constructor(data?: PartialMessage<ExecuteRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.ExecuteRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'query', kind: 'message', T: BoundQuery },
        { no: 5, name: 'transaction_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 6, name: 'options', kind: 'message', T: ExecuteOptions },
        { no: 7, name: 'reserved_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteRequest {
        return new ExecuteRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteRequest {
        return new ExecuteRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteRequest {
        return new ExecuteRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: ExecuteRequest | PlainMessage<ExecuteRequest> | undefined,
        b: ExecuteRequest | PlainMessage<ExecuteRequest> | undefined,
    ): boolean {
        return proto3.util.equals(ExecuteRequest, a, b);
    }
}

/**
 * ExecuteResponse is the returned value from Execute
 *
 * @generated from message query.ExecuteResponse
 */
export class ExecuteResponse extends Message<ExecuteResponse> {
    /**
     * @generated from field: query.QueryResult result = 1;
     */
    result?: QueryResult;

    constructor(data?: PartialMessage<ExecuteResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.ExecuteResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'result', kind: 'message', T: QueryResult },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteResponse {
        return new ExecuteResponse().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteResponse {
        return new ExecuteResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteResponse {
        return new ExecuteResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: ExecuteResponse | PlainMessage<ExecuteResponse> | undefined,
        b: ExecuteResponse | PlainMessage<ExecuteResponse> | undefined,
    ): boolean {
        return proto3.util.equals(ExecuteResponse, a, b);
    }
}

/**
 * ResultWithError represents a query response
 * in the form of result or error but not both.
 * TODO: To be used in ExecuteBatchResponse and BeginExecuteBatchResponse.
 *
 * @generated from message query.ResultWithError
 */
export class ResultWithError extends Message<ResultWithError> {
    /**
     * error contains an query level error, only set if result is unset.
     *
     * @generated from field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;

    /**
     * result contains the query result, only set if error is unset.
     *
     * @generated from field: query.QueryResult result = 2;
     */
    result?: QueryResult;

    constructor(data?: PartialMessage<ResultWithError>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.ResultWithError';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'error', kind: 'message', T: RPCError },
        { no: 2, name: 'result', kind: 'message', T: QueryResult },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResultWithError {
        return new ResultWithError().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResultWithError {
        return new ResultWithError().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResultWithError {
        return new ResultWithError().fromJsonString(jsonString, options);
    }

    static equals(
        a: ResultWithError | PlainMessage<ResultWithError> | undefined,
        b: ResultWithError | PlainMessage<ResultWithError> | undefined,
    ): boolean {
        return proto3.util.equals(ResultWithError, a, b);
    }
}

/**
 * StreamExecuteRequest is the payload to StreamExecute
 *
 * @generated from message query.StreamExecuteRequest
 */
export class StreamExecuteRequest extends Message<StreamExecuteRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: query.BoundQuery query = 4;
     */
    query?: BoundQuery;

    /**
     * @generated from field: query.ExecuteOptions options = 5;
     */
    options?: ExecuteOptions;

    /**
     * @generated from field: int64 transaction_id = 6;
     */
    transactionId = protoInt64.zero;

    /**
     * @generated from field: int64 reserved_id = 7;
     */
    reservedId = protoInt64.zero;

    constructor(data?: PartialMessage<StreamExecuteRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.StreamExecuteRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'query', kind: 'message', T: BoundQuery },
        { no: 5, name: 'options', kind: 'message', T: ExecuteOptions },
        { no: 6, name: 'transaction_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 7, name: 'reserved_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): StreamExecuteRequest {
        return new StreamExecuteRequest().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): StreamExecuteRequest {
        return new StreamExecuteRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): StreamExecuteRequest {
        return new StreamExecuteRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: StreamExecuteRequest | PlainMessage<StreamExecuteRequest> | undefined,
        b: StreamExecuteRequest | PlainMessage<StreamExecuteRequest> | undefined,
    ): boolean {
        return proto3.util.equals(StreamExecuteRequest, a, b);
    }
}

/**
 * StreamExecuteResponse is the returned value from StreamExecute
 *
 * @generated from message query.StreamExecuteResponse
 */
export class StreamExecuteResponse extends Message<StreamExecuteResponse> {
    /**
     * @generated from field: query.QueryResult result = 1;
     */
    result?: QueryResult;

    constructor(data?: PartialMessage<StreamExecuteResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.StreamExecuteResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'result', kind: 'message', T: QueryResult },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): StreamExecuteResponse {
        return new StreamExecuteResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): StreamExecuteResponse {
        return new StreamExecuteResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): StreamExecuteResponse {
        return new StreamExecuteResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: StreamExecuteResponse | PlainMessage<StreamExecuteResponse> | undefined,
        b: StreamExecuteResponse | PlainMessage<StreamExecuteResponse> | undefined,
    ): boolean {
        return proto3.util.equals(StreamExecuteResponse, a, b);
    }
}

/**
 * BeginRequest is the payload to Begin
 *
 * @generated from message query.BeginRequest
 */
export class BeginRequest extends Message<BeginRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: query.ExecuteOptions options = 4;
     */
    options?: ExecuteOptions;

    constructor(data?: PartialMessage<BeginRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.BeginRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'options', kind: 'message', T: ExecuteOptions },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BeginRequest {
        return new BeginRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BeginRequest {
        return new BeginRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BeginRequest {
        return new BeginRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: BeginRequest | PlainMessage<BeginRequest> | undefined,
        b: BeginRequest | PlainMessage<BeginRequest> | undefined,
    ): boolean {
        return proto3.util.equals(BeginRequest, a, b);
    }
}

/**
 * BeginResponse is the returned value from Begin
 *
 * @generated from message query.BeginResponse
 */
export class BeginResponse extends Message<BeginResponse> {
    /**
     * @generated from field: int64 transaction_id = 1;
     */
    transactionId = protoInt64.zero;

    /**
     * @generated from field: topodata.TabletAlias tablet_alias = 2;
     */
    tabletAlias?: TabletAlias;

    /**
     * The session_state_changes might be set if the transaction is a snapshot transaction
     * and the MySQL implementation supports getting a start gtid on snapshot
     *
     * @generated from field: string session_state_changes = 3;
     */
    sessionStateChanges = '';

    constructor(data?: PartialMessage<BeginResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.BeginResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'transaction_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 2, name: 'tablet_alias', kind: 'message', T: TabletAlias },
        { no: 3, name: 'session_state_changes', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BeginResponse {
        return new BeginResponse().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BeginResponse {
        return new BeginResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BeginResponse {
        return new BeginResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: BeginResponse | PlainMessage<BeginResponse> | undefined,
        b: BeginResponse | PlainMessage<BeginResponse> | undefined,
    ): boolean {
        return proto3.util.equals(BeginResponse, a, b);
    }
}

/**
 * CommitRequest is the payload to Commit
 *
 * @generated from message query.CommitRequest
 */
export class CommitRequest extends Message<CommitRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: int64 transaction_id = 4;
     */
    transactionId = protoInt64.zero;

    constructor(data?: PartialMessage<CommitRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.CommitRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'transaction_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommitRequest {
        return new CommitRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommitRequest {
        return new CommitRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommitRequest {
        return new CommitRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: CommitRequest | PlainMessage<CommitRequest> | undefined,
        b: CommitRequest | PlainMessage<CommitRequest> | undefined,
    ): boolean {
        return proto3.util.equals(CommitRequest, a, b);
    }
}

/**
 * CommitResponse is the returned value from Commit
 *
 * @generated from message query.CommitResponse
 */
export class CommitResponse extends Message<CommitResponse> {
    /**
     * @generated from field: int64 reserved_id = 1;
     */
    reservedId = protoInt64.zero;

    constructor(data?: PartialMessage<CommitResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.CommitResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'reserved_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommitResponse {
        return new CommitResponse().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommitResponse {
        return new CommitResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommitResponse {
        return new CommitResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: CommitResponse | PlainMessage<CommitResponse> | undefined,
        b: CommitResponse | PlainMessage<CommitResponse> | undefined,
    ): boolean {
        return proto3.util.equals(CommitResponse, a, b);
    }
}

/**
 * RollbackRequest is the payload to Rollback
 *
 * @generated from message query.RollbackRequest
 */
export class RollbackRequest extends Message<RollbackRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: int64 transaction_id = 4;
     */
    transactionId = protoInt64.zero;

    constructor(data?: PartialMessage<RollbackRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.RollbackRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'transaction_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RollbackRequest {
        return new RollbackRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RollbackRequest {
        return new RollbackRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RollbackRequest {
        return new RollbackRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: RollbackRequest | PlainMessage<RollbackRequest> | undefined,
        b: RollbackRequest | PlainMessage<RollbackRequest> | undefined,
    ): boolean {
        return proto3.util.equals(RollbackRequest, a, b);
    }
}

/**
 * RollbackResponse is the returned value from Rollback
 *
 * @generated from message query.RollbackResponse
 */
export class RollbackResponse extends Message<RollbackResponse> {
    /**
     * @generated from field: int64 reserved_id = 1;
     */
    reservedId = protoInt64.zero;

    constructor(data?: PartialMessage<RollbackResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.RollbackResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'reserved_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RollbackResponse {
        return new RollbackResponse().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RollbackResponse {
        return new RollbackResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): RollbackResponse {
        return new RollbackResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: RollbackResponse | PlainMessage<RollbackResponse> | undefined,
        b: RollbackResponse | PlainMessage<RollbackResponse> | undefined,
    ): boolean {
        return proto3.util.equals(RollbackResponse, a, b);
    }
}

/**
 * PrepareRequest is the payload to Prepare
 *
 * @generated from message query.PrepareRequest
 */
export class PrepareRequest extends Message<PrepareRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: int64 transaction_id = 4;
     */
    transactionId = protoInt64.zero;

    /**
     * @generated from field: string dtid = 5;
     */
    dtid = '';

    constructor(data?: PartialMessage<PrepareRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.PrepareRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'transaction_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 5, name: 'dtid', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrepareRequest {
        return new PrepareRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrepareRequest {
        return new PrepareRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrepareRequest {
        return new PrepareRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: PrepareRequest | PlainMessage<PrepareRequest> | undefined,
        b: PrepareRequest | PlainMessage<PrepareRequest> | undefined,
    ): boolean {
        return proto3.util.equals(PrepareRequest, a, b);
    }
}

/**
 * PrepareResponse is the returned value from Prepare
 *
 * @generated from message query.PrepareResponse
 */
export class PrepareResponse extends Message<PrepareResponse> {
    constructor(data?: PartialMessage<PrepareResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.PrepareResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => []);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrepareResponse {
        return new PrepareResponse().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrepareResponse {
        return new PrepareResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrepareResponse {
        return new PrepareResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: PrepareResponse | PlainMessage<PrepareResponse> | undefined,
        b: PrepareResponse | PlainMessage<PrepareResponse> | undefined,
    ): boolean {
        return proto3.util.equals(PrepareResponse, a, b);
    }
}

/**
 * CommitPreparedRequest is the payload to CommitPrepared
 *
 * @generated from message query.CommitPreparedRequest
 */
export class CommitPreparedRequest extends Message<CommitPreparedRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: string dtid = 4;
     */
    dtid = '';

    constructor(data?: PartialMessage<CommitPreparedRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.CommitPreparedRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'dtid', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): CommitPreparedRequest {
        return new CommitPreparedRequest().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): CommitPreparedRequest {
        return new CommitPreparedRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): CommitPreparedRequest {
        return new CommitPreparedRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: CommitPreparedRequest | PlainMessage<CommitPreparedRequest> | undefined,
        b: CommitPreparedRequest | PlainMessage<CommitPreparedRequest> | undefined,
    ): boolean {
        return proto3.util.equals(CommitPreparedRequest, a, b);
    }
}

/**
 * CommitPreparedResponse is the returned value from CommitPrepared
 *
 * @generated from message query.CommitPreparedResponse
 */
export class CommitPreparedResponse extends Message<CommitPreparedResponse> {
    constructor(data?: PartialMessage<CommitPreparedResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.CommitPreparedResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => []);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): CommitPreparedResponse {
        return new CommitPreparedResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): CommitPreparedResponse {
        return new CommitPreparedResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): CommitPreparedResponse {
        return new CommitPreparedResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: CommitPreparedResponse | PlainMessage<CommitPreparedResponse> | undefined,
        b: CommitPreparedResponse | PlainMessage<CommitPreparedResponse> | undefined,
    ): boolean {
        return proto3.util.equals(CommitPreparedResponse, a, b);
    }
}

/**
 * RollbackPreparedRequest is the payload to RollbackPrepared
 *
 * @generated from message query.RollbackPreparedRequest
 */
export class RollbackPreparedRequest extends Message<RollbackPreparedRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: int64 transaction_id = 4;
     */
    transactionId = protoInt64.zero;

    /**
     * @generated from field: string dtid = 5;
     */
    dtid = '';

    constructor(data?: PartialMessage<RollbackPreparedRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.RollbackPreparedRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'transaction_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 5, name: 'dtid', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): RollbackPreparedRequest {
        return new RollbackPreparedRequest().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): RollbackPreparedRequest {
        return new RollbackPreparedRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): RollbackPreparedRequest {
        return new RollbackPreparedRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: RollbackPreparedRequest | PlainMessage<RollbackPreparedRequest> | undefined,
        b: RollbackPreparedRequest | PlainMessage<RollbackPreparedRequest> | undefined,
    ): boolean {
        return proto3.util.equals(RollbackPreparedRequest, a, b);
    }
}

/**
 * RollbackPreparedResponse is the returned value from RollbackPrepared
 *
 * @generated from message query.RollbackPreparedResponse
 */
export class RollbackPreparedResponse extends Message<RollbackPreparedResponse> {
    constructor(data?: PartialMessage<RollbackPreparedResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.RollbackPreparedResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => []);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): RollbackPreparedResponse {
        return new RollbackPreparedResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): RollbackPreparedResponse {
        return new RollbackPreparedResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): RollbackPreparedResponse {
        return new RollbackPreparedResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: RollbackPreparedResponse | PlainMessage<RollbackPreparedResponse> | undefined,
        b: RollbackPreparedResponse | PlainMessage<RollbackPreparedResponse> | undefined,
    ): boolean {
        return proto3.util.equals(RollbackPreparedResponse, a, b);
    }
}

/**
 * CreateTransactionRequest is the payload to CreateTransaction
 *
 * @generated from message query.CreateTransactionRequest
 */
export class CreateTransactionRequest extends Message<CreateTransactionRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: string dtid = 4;
     */
    dtid = '';

    /**
     * @generated from field: repeated query.Target participants = 5;
     */
    participants: Target[] = [];

    constructor(data?: PartialMessage<CreateTransactionRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.CreateTransactionRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'dtid', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 5, name: 'participants', kind: 'message', T: Target, repeated: true },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): CreateTransactionRequest {
        return new CreateTransactionRequest().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): CreateTransactionRequest {
        return new CreateTransactionRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): CreateTransactionRequest {
        return new CreateTransactionRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: CreateTransactionRequest | PlainMessage<CreateTransactionRequest> | undefined,
        b: CreateTransactionRequest | PlainMessage<CreateTransactionRequest> | undefined,
    ): boolean {
        return proto3.util.equals(CreateTransactionRequest, a, b);
    }
}

/**
 * CreateTransactionResponse is the returned value from CreateTransaction
 *
 * @generated from message query.CreateTransactionResponse
 */
export class CreateTransactionResponse extends Message<CreateTransactionResponse> {
    constructor(data?: PartialMessage<CreateTransactionResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.CreateTransactionResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => []);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): CreateTransactionResponse {
        return new CreateTransactionResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): CreateTransactionResponse {
        return new CreateTransactionResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): CreateTransactionResponse {
        return new CreateTransactionResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: CreateTransactionResponse | PlainMessage<CreateTransactionResponse> | undefined,
        b: CreateTransactionResponse | PlainMessage<CreateTransactionResponse> | undefined,
    ): boolean {
        return proto3.util.equals(CreateTransactionResponse, a, b);
    }
}

/**
 * StartCommitRequest is the payload to StartCommit
 *
 * @generated from message query.StartCommitRequest
 */
export class StartCommitRequest extends Message<StartCommitRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: int64 transaction_id = 4;
     */
    transactionId = protoInt64.zero;

    /**
     * @generated from field: string dtid = 5;
     */
    dtid = '';

    constructor(data?: PartialMessage<StartCommitRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.StartCommitRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'transaction_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 5, name: 'dtid', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartCommitRequest {
        return new StartCommitRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartCommitRequest {
        return new StartCommitRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): StartCommitRequest {
        return new StartCommitRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: StartCommitRequest | PlainMessage<StartCommitRequest> | undefined,
        b: StartCommitRequest | PlainMessage<StartCommitRequest> | undefined,
    ): boolean {
        return proto3.util.equals(StartCommitRequest, a, b);
    }
}

/**
 * StartCommitResponse is the returned value from StartCommit
 *
 * @generated from message query.StartCommitResponse
 */
export class StartCommitResponse extends Message<StartCommitResponse> {
    constructor(data?: PartialMessage<StartCommitResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.StartCommitResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => []);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): StartCommitResponse {
        return new StartCommitResponse().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartCommitResponse {
        return new StartCommitResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): StartCommitResponse {
        return new StartCommitResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: StartCommitResponse | PlainMessage<StartCommitResponse> | undefined,
        b: StartCommitResponse | PlainMessage<StartCommitResponse> | undefined,
    ): boolean {
        return proto3.util.equals(StartCommitResponse, a, b);
    }
}

/**
 * SetRollbackRequest is the payload to SetRollback
 *
 * @generated from message query.SetRollbackRequest
 */
export class SetRollbackRequest extends Message<SetRollbackRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: int64 transaction_id = 4;
     */
    transactionId = protoInt64.zero;

    /**
     * @generated from field: string dtid = 5;
     */
    dtid = '';

    constructor(data?: PartialMessage<SetRollbackRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.SetRollbackRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'transaction_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 5, name: 'dtid', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetRollbackRequest {
        return new SetRollbackRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetRollbackRequest {
        return new SetRollbackRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): SetRollbackRequest {
        return new SetRollbackRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: SetRollbackRequest | PlainMessage<SetRollbackRequest> | undefined,
        b: SetRollbackRequest | PlainMessage<SetRollbackRequest> | undefined,
    ): boolean {
        return proto3.util.equals(SetRollbackRequest, a, b);
    }
}

/**
 * SetRollbackResponse is the returned value from SetRollback
 *
 * @generated from message query.SetRollbackResponse
 */
export class SetRollbackResponse extends Message<SetRollbackResponse> {
    constructor(data?: PartialMessage<SetRollbackResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.SetRollbackResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => []);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): SetRollbackResponse {
        return new SetRollbackResponse().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetRollbackResponse {
        return new SetRollbackResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): SetRollbackResponse {
        return new SetRollbackResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: SetRollbackResponse | PlainMessage<SetRollbackResponse> | undefined,
        b: SetRollbackResponse | PlainMessage<SetRollbackResponse> | undefined,
    ): boolean {
        return proto3.util.equals(SetRollbackResponse, a, b);
    }
}

/**
 * ConcludeTransactionRequest is the payload to ConcludeTransaction
 *
 * @generated from message query.ConcludeTransactionRequest
 */
export class ConcludeTransactionRequest extends Message<ConcludeTransactionRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: string dtid = 4;
     */
    dtid = '';

    constructor(data?: PartialMessage<ConcludeTransactionRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.ConcludeTransactionRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'dtid', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ConcludeTransactionRequest {
        return new ConcludeTransactionRequest().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ConcludeTransactionRequest {
        return new ConcludeTransactionRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ConcludeTransactionRequest {
        return new ConcludeTransactionRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: ConcludeTransactionRequest | PlainMessage<ConcludeTransactionRequest> | undefined,
        b: ConcludeTransactionRequest | PlainMessage<ConcludeTransactionRequest> | undefined,
    ): boolean {
        return proto3.util.equals(ConcludeTransactionRequest, a, b);
    }
}

/**
 * ConcludeTransactionResponse is the returned value from ConcludeTransaction
 *
 * @generated from message query.ConcludeTransactionResponse
 */
export class ConcludeTransactionResponse extends Message<ConcludeTransactionResponse> {
    constructor(data?: PartialMessage<ConcludeTransactionResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.ConcludeTransactionResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => []);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ConcludeTransactionResponse {
        return new ConcludeTransactionResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ConcludeTransactionResponse {
        return new ConcludeTransactionResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ConcludeTransactionResponse {
        return new ConcludeTransactionResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: ConcludeTransactionResponse | PlainMessage<ConcludeTransactionResponse> | undefined,
        b: ConcludeTransactionResponse | PlainMessage<ConcludeTransactionResponse> | undefined,
    ): boolean {
        return proto3.util.equals(ConcludeTransactionResponse, a, b);
    }
}

/**
 * ReadTransactionRequest is the payload to ReadTransaction
 *
 * @generated from message query.ReadTransactionRequest
 */
export class ReadTransactionRequest extends Message<ReadTransactionRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: string dtid = 4;
     */
    dtid = '';

    constructor(data?: PartialMessage<ReadTransactionRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.ReadTransactionRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'dtid', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ReadTransactionRequest {
        return new ReadTransactionRequest().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ReadTransactionRequest {
        return new ReadTransactionRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ReadTransactionRequest {
        return new ReadTransactionRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: ReadTransactionRequest | PlainMessage<ReadTransactionRequest> | undefined,
        b: ReadTransactionRequest | PlainMessage<ReadTransactionRequest> | undefined,
    ): boolean {
        return proto3.util.equals(ReadTransactionRequest, a, b);
    }
}

/**
 * ReadTransactionResponse is the returned value from ReadTransaction
 *
 * @generated from message query.ReadTransactionResponse
 */
export class ReadTransactionResponse extends Message<ReadTransactionResponse> {
    /**
     * @generated from field: query.TransactionMetadata metadata = 1;
     */
    metadata?: TransactionMetadata;

    constructor(data?: PartialMessage<ReadTransactionResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.ReadTransactionResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'metadata', kind: 'message', T: TransactionMetadata },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ReadTransactionResponse {
        return new ReadTransactionResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ReadTransactionResponse {
        return new ReadTransactionResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ReadTransactionResponse {
        return new ReadTransactionResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: ReadTransactionResponse | PlainMessage<ReadTransactionResponse> | undefined,
        b: ReadTransactionResponse | PlainMessage<ReadTransactionResponse> | undefined,
    ): boolean {
        return proto3.util.equals(ReadTransactionResponse, a, b);
    }
}

/**
 * UnresolvedTransactionsRequest is the payload to UnresolvedTransactions
 *
 * @generated from message query.UnresolvedTransactionsRequest
 */
export class UnresolvedTransactionsRequest extends Message<UnresolvedTransactionsRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * Unresolved Transactions older than this (in seconds).
     *
     * @generated from field: int64 abandon_age = 4;
     */
    abandonAge = protoInt64.zero;

    constructor(data?: PartialMessage<UnresolvedTransactionsRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.UnresolvedTransactionsRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'abandon_age', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): UnresolvedTransactionsRequest {
        return new UnresolvedTransactionsRequest().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): UnresolvedTransactionsRequest {
        return new UnresolvedTransactionsRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): UnresolvedTransactionsRequest {
        return new UnresolvedTransactionsRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: UnresolvedTransactionsRequest | PlainMessage<UnresolvedTransactionsRequest> | undefined,
        b: UnresolvedTransactionsRequest | PlainMessage<UnresolvedTransactionsRequest> | undefined,
    ): boolean {
        return proto3.util.equals(UnresolvedTransactionsRequest, a, b);
    }
}

/**
 * UnresolvedTransactionsResponse is the returned value from UnresolvedTransactions
 *
 * @generated from message query.UnresolvedTransactionsResponse
 */
export class UnresolvedTransactionsResponse extends Message<UnresolvedTransactionsResponse> {
    /**
     * @generated from field: repeated query.TransactionMetadata transactions = 1;
     */
    transactions: TransactionMetadata[] = [];

    constructor(data?: PartialMessage<UnresolvedTransactionsResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.UnresolvedTransactionsResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'transactions', kind: 'message', T: TransactionMetadata, repeated: true },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): UnresolvedTransactionsResponse {
        return new UnresolvedTransactionsResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): UnresolvedTransactionsResponse {
        return new UnresolvedTransactionsResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): UnresolvedTransactionsResponse {
        return new UnresolvedTransactionsResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a:
            | UnresolvedTransactionsResponse
            | PlainMessage<UnresolvedTransactionsResponse>
            | undefined,
        b:
            | UnresolvedTransactionsResponse
            | PlainMessage<UnresolvedTransactionsResponse>
            | undefined,
    ): boolean {
        return proto3.util.equals(UnresolvedTransactionsResponse, a, b);
    }
}

/**
 * BeginExecuteRequest is the payload to BeginExecute
 *
 * @generated from message query.BeginExecuteRequest
 */
export class BeginExecuteRequest extends Message<BeginExecuteRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: query.BoundQuery query = 4;
     */
    query?: BoundQuery;

    /**
     * @generated from field: query.ExecuteOptions options = 5;
     */
    options?: ExecuteOptions;

    /**
     * @generated from field: int64 reserved_id = 6;
     */
    reservedId = protoInt64.zero;

    /**
     * @generated from field: repeated string pre_queries = 7;
     */
    preQueries: string[] = [];

    constructor(data?: PartialMessage<BeginExecuteRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.BeginExecuteRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'query', kind: 'message', T: BoundQuery },
        { no: 5, name: 'options', kind: 'message', T: ExecuteOptions },
        { no: 6, name: 'reserved_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        {
            no: 7,
            name: 'pre_queries',
            kind: 'scalar',
            T: 9 /* ScalarType.STRING */,
            repeated: true,
        },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): BeginExecuteRequest {
        return new BeginExecuteRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BeginExecuteRequest {
        return new BeginExecuteRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): BeginExecuteRequest {
        return new BeginExecuteRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: BeginExecuteRequest | PlainMessage<BeginExecuteRequest> | undefined,
        b: BeginExecuteRequest | PlainMessage<BeginExecuteRequest> | undefined,
    ): boolean {
        return proto3.util.equals(BeginExecuteRequest, a, b);
    }
}

/**
 * BeginExecuteResponse is the returned value from BeginExecute
 *
 * @generated from message query.BeginExecuteResponse
 */
export class BeginExecuteResponse extends Message<BeginExecuteResponse> {
    /**
     * error contains an application level error if necessary. Note the
     * transaction_id may be set, even when an error is returned, if the begin
     * worked but the execute failed.
     *
     * @generated from field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;

    /**
     * @generated from field: query.QueryResult result = 2;
     */
    result?: QueryResult;

    /**
     * transaction_id might be non-zero even if an error is present.
     *
     * @generated from field: int64 transaction_id = 3;
     */
    transactionId = protoInt64.zero;

    /**
     * @generated from field: topodata.TabletAlias tablet_alias = 4;
     */
    tabletAlias?: TabletAlias;

    /**
     * The session_state_changes might be set if the transaction is a snapshot transaction
     * and the MySQL implementation supports getting a start gtid on snapshot
     *
     * @generated from field: string session_state_changes = 5;
     */
    sessionStateChanges = '';

    constructor(data?: PartialMessage<BeginExecuteResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.BeginExecuteResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'error', kind: 'message', T: RPCError },
        { no: 2, name: 'result', kind: 'message', T: QueryResult },
        { no: 3, name: 'transaction_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 4, name: 'tablet_alias', kind: 'message', T: TabletAlias },
        { no: 5, name: 'session_state_changes', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): BeginExecuteResponse {
        return new BeginExecuteResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): BeginExecuteResponse {
        return new BeginExecuteResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): BeginExecuteResponse {
        return new BeginExecuteResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: BeginExecuteResponse | PlainMessage<BeginExecuteResponse> | undefined,
        b: BeginExecuteResponse | PlainMessage<BeginExecuteResponse> | undefined,
    ): boolean {
        return proto3.util.equals(BeginExecuteResponse, a, b);
    }
}

/**
 * BeginStreamExecuteRequest is the payload to BeginStreamExecute
 *
 * @generated from message query.BeginStreamExecuteRequest
 */
export class BeginStreamExecuteRequest extends Message<BeginStreamExecuteRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: query.BoundQuery query = 4;
     */
    query?: BoundQuery;

    /**
     * @generated from field: query.ExecuteOptions options = 5;
     */
    options?: ExecuteOptions;

    /**
     * @generated from field: repeated string pre_queries = 6;
     */
    preQueries: string[] = [];

    /**
     * @generated from field: int64 reserved_id = 7;
     */
    reservedId = protoInt64.zero;

    constructor(data?: PartialMessage<BeginStreamExecuteRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.BeginStreamExecuteRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'query', kind: 'message', T: BoundQuery },
        { no: 5, name: 'options', kind: 'message', T: ExecuteOptions },
        {
            no: 6,
            name: 'pre_queries',
            kind: 'scalar',
            T: 9 /* ScalarType.STRING */,
            repeated: true,
        },
        { no: 7, name: 'reserved_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): BeginStreamExecuteRequest {
        return new BeginStreamExecuteRequest().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): BeginStreamExecuteRequest {
        return new BeginStreamExecuteRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): BeginStreamExecuteRequest {
        return new BeginStreamExecuteRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: BeginStreamExecuteRequest | PlainMessage<BeginStreamExecuteRequest> | undefined,
        b: BeginStreamExecuteRequest | PlainMessage<BeginStreamExecuteRequest> | undefined,
    ): boolean {
        return proto3.util.equals(BeginStreamExecuteRequest, a, b);
    }
}

/**
 * BeginStreamExecuteResponse is the returned value from BeginStreamExecute
 *
 * @generated from message query.BeginStreamExecuteResponse
 */
export class BeginStreamExecuteResponse extends Message<BeginStreamExecuteResponse> {
    /**
     * error contains an application level error if necessary. Note the
     * transaction_id may be set, even when an error is returned, if the begin
     * worked but the stream execute failed.
     *
     * @generated from field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;

    /**
     * @generated from field: query.QueryResult result = 2;
     */
    result?: QueryResult;

    /**
     * transaction_id might be non-zero even if an error is present.
     *
     * @generated from field: int64 transaction_id = 3;
     */
    transactionId = protoInt64.zero;

    /**
     * @generated from field: topodata.TabletAlias tablet_alias = 4;
     */
    tabletAlias?: TabletAlias;

    /**
     * The session_state_changes might be set if the transaction is a snapshot transaction
     * and the MySQL implementation supports getting a start gtid on snapshot
     *
     * @generated from field: string session_state_changes = 5;
     */
    sessionStateChanges = '';

    constructor(data?: PartialMessage<BeginStreamExecuteResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.BeginStreamExecuteResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'error', kind: 'message', T: RPCError },
        { no: 2, name: 'result', kind: 'message', T: QueryResult },
        { no: 3, name: 'transaction_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 4, name: 'tablet_alias', kind: 'message', T: TabletAlias },
        { no: 5, name: 'session_state_changes', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): BeginStreamExecuteResponse {
        return new BeginStreamExecuteResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): BeginStreamExecuteResponse {
        return new BeginStreamExecuteResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): BeginStreamExecuteResponse {
        return new BeginStreamExecuteResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: BeginStreamExecuteResponse | PlainMessage<BeginStreamExecuteResponse> | undefined,
        b: BeginStreamExecuteResponse | PlainMessage<BeginStreamExecuteResponse> | undefined,
    ): boolean {
        return proto3.util.equals(BeginStreamExecuteResponse, a, b);
    }
}

/**
 * MessageStreamRequest is the request payload for MessageStream.
 *
 * @generated from message query.MessageStreamRequest
 */
export class MessageStreamRequest extends Message<MessageStreamRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * name is the message table name.
     *
     * @generated from field: string name = 4;
     */
    name = '';

    constructor(data?: PartialMessage<MessageStreamRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.MessageStreamRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): MessageStreamRequest {
        return new MessageStreamRequest().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): MessageStreamRequest {
        return new MessageStreamRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): MessageStreamRequest {
        return new MessageStreamRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: MessageStreamRequest | PlainMessage<MessageStreamRequest> | undefined,
        b: MessageStreamRequest | PlainMessage<MessageStreamRequest> | undefined,
    ): boolean {
        return proto3.util.equals(MessageStreamRequest, a, b);
    }
}

/**
 * MessageStreamResponse is a response for MessageStream.
 *
 * @generated from message query.MessageStreamResponse
 */
export class MessageStreamResponse extends Message<MessageStreamResponse> {
    /**
     * @generated from field: query.QueryResult result = 1;
     */
    result?: QueryResult;

    constructor(data?: PartialMessage<MessageStreamResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.MessageStreamResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'result', kind: 'message', T: QueryResult },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): MessageStreamResponse {
        return new MessageStreamResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): MessageStreamResponse {
        return new MessageStreamResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): MessageStreamResponse {
        return new MessageStreamResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: MessageStreamResponse | PlainMessage<MessageStreamResponse> | undefined,
        b: MessageStreamResponse | PlainMessage<MessageStreamResponse> | undefined,
    ): boolean {
        return proto3.util.equals(MessageStreamResponse, a, b);
    }
}

/**
 * MessageAckRequest is the request payload for MessageAck.
 *
 * @generated from message query.MessageAckRequest
 */
export class MessageAckRequest extends Message<MessageAckRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * name is the message table name.
     *
     * @generated from field: string name = 4;
     */
    name = '';

    /**
     * @generated from field: repeated query.Value ids = 5;
     */
    ids: Value[] = [];

    constructor(data?: PartialMessage<MessageAckRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.MessageAckRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 5, name: 'ids', kind: 'message', T: Value, repeated: true },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MessageAckRequest {
        return new MessageAckRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MessageAckRequest {
        return new MessageAckRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): MessageAckRequest {
        return new MessageAckRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: MessageAckRequest | PlainMessage<MessageAckRequest> | undefined,
        b: MessageAckRequest | PlainMessage<MessageAckRequest> | undefined,
    ): boolean {
        return proto3.util.equals(MessageAckRequest, a, b);
    }
}

/**
 * MessageAckResponse is the response for MessageAck.
 *
 * @generated from message query.MessageAckResponse
 */
export class MessageAckResponse extends Message<MessageAckResponse> {
    /**
     * result contains the result of the ack operation.
     * Since this acts like a DML, only
     * RowsAffected is returned in the result.
     *
     * @generated from field: query.QueryResult result = 1;
     */
    result?: QueryResult;

    constructor(data?: PartialMessage<MessageAckResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.MessageAckResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'result', kind: 'message', T: QueryResult },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MessageAckResponse {
        return new MessageAckResponse().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MessageAckResponse {
        return new MessageAckResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): MessageAckResponse {
        return new MessageAckResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: MessageAckResponse | PlainMessage<MessageAckResponse> | undefined,
        b: MessageAckResponse | PlainMessage<MessageAckResponse> | undefined,
    ): boolean {
        return proto3.util.equals(MessageAckResponse, a, b);
    }
}

/**
 * ReserveExecuteRequest is the payload to ReserveExecute
 *
 * @generated from message query.ReserveExecuteRequest
 */
export class ReserveExecuteRequest extends Message<ReserveExecuteRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: query.BoundQuery query = 4;
     */
    query?: BoundQuery;

    /**
     * @generated from field: int64 transaction_id = 5;
     */
    transactionId = protoInt64.zero;

    /**
     * @generated from field: query.ExecuteOptions options = 6;
     */
    options?: ExecuteOptions;

    /**
     * @generated from field: repeated string pre_queries = 7;
     */
    preQueries: string[] = [];

    constructor(data?: PartialMessage<ReserveExecuteRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.ReserveExecuteRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'query', kind: 'message', T: BoundQuery },
        { no: 5, name: 'transaction_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 6, name: 'options', kind: 'message', T: ExecuteOptions },
        {
            no: 7,
            name: 'pre_queries',
            kind: 'scalar',
            T: 9 /* ScalarType.STRING */,
            repeated: true,
        },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ReserveExecuteRequest {
        return new ReserveExecuteRequest().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ReserveExecuteRequest {
        return new ReserveExecuteRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ReserveExecuteRequest {
        return new ReserveExecuteRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: ReserveExecuteRequest | PlainMessage<ReserveExecuteRequest> | undefined,
        b: ReserveExecuteRequest | PlainMessage<ReserveExecuteRequest> | undefined,
    ): boolean {
        return proto3.util.equals(ReserveExecuteRequest, a, b);
    }
}

/**
 * ReserveExecuteResponse is the returned value from ReserveExecute
 *
 * @generated from message query.ReserveExecuteResponse
 */
export class ReserveExecuteResponse extends Message<ReserveExecuteResponse> {
    /**
     * @generated from field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;

    /**
     * @generated from field: query.QueryResult result = 2;
     */
    result?: QueryResult;

    /**
     * The following fields might be non-zero even if an error is present.
     *
     * @generated from field: int64 reserved_id = 3;
     */
    reservedId = protoInt64.zero;

    /**
     * @generated from field: topodata.TabletAlias tablet_alias = 4;
     */
    tabletAlias?: TabletAlias;

    constructor(data?: PartialMessage<ReserveExecuteResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.ReserveExecuteResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'error', kind: 'message', T: RPCError },
        { no: 2, name: 'result', kind: 'message', T: QueryResult },
        { no: 3, name: 'reserved_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 4, name: 'tablet_alias', kind: 'message', T: TabletAlias },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ReserveExecuteResponse {
        return new ReserveExecuteResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ReserveExecuteResponse {
        return new ReserveExecuteResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ReserveExecuteResponse {
        return new ReserveExecuteResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: ReserveExecuteResponse | PlainMessage<ReserveExecuteResponse> | undefined,
        b: ReserveExecuteResponse | PlainMessage<ReserveExecuteResponse> | undefined,
    ): boolean {
        return proto3.util.equals(ReserveExecuteResponse, a, b);
    }
}

/**
 * ReserveStreamExecuteRequest is the payload to ReserveStreamExecute
 *
 * @generated from message query.ReserveStreamExecuteRequest
 */
export class ReserveStreamExecuteRequest extends Message<ReserveStreamExecuteRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: query.BoundQuery query = 4;
     */
    query?: BoundQuery;

    /**
     * @generated from field: query.ExecuteOptions options = 5;
     */
    options?: ExecuteOptions;

    /**
     * @generated from field: int64 transaction_id = 6;
     */
    transactionId = protoInt64.zero;

    /**
     * @generated from field: repeated string pre_queries = 7;
     */
    preQueries: string[] = [];

    constructor(data?: PartialMessage<ReserveStreamExecuteRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.ReserveStreamExecuteRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'query', kind: 'message', T: BoundQuery },
        { no: 5, name: 'options', kind: 'message', T: ExecuteOptions },
        { no: 6, name: 'transaction_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        {
            no: 7,
            name: 'pre_queries',
            kind: 'scalar',
            T: 9 /* ScalarType.STRING */,
            repeated: true,
        },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ReserveStreamExecuteRequest {
        return new ReserveStreamExecuteRequest().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ReserveStreamExecuteRequest {
        return new ReserveStreamExecuteRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ReserveStreamExecuteRequest {
        return new ReserveStreamExecuteRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: ReserveStreamExecuteRequest | PlainMessage<ReserveStreamExecuteRequest> | undefined,
        b: ReserveStreamExecuteRequest | PlainMessage<ReserveStreamExecuteRequest> | undefined,
    ): boolean {
        return proto3.util.equals(ReserveStreamExecuteRequest, a, b);
    }
}

/**
 * ReserveStreamExecuteResponse is the returned value from ReserveStreamExecute
 *
 * @generated from message query.ReserveStreamExecuteResponse
 */
export class ReserveStreamExecuteResponse extends Message<ReserveStreamExecuteResponse> {
    /**
     * @generated from field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;

    /**
     * @generated from field: query.QueryResult result = 2;
     */
    result?: QueryResult;

    /**
     * The following fields might be non-zero even if an error is present.
     *
     * @generated from field: int64 reserved_id = 3;
     */
    reservedId = protoInt64.zero;

    /**
     * @generated from field: topodata.TabletAlias tablet_alias = 4;
     */
    tabletAlias?: TabletAlias;

    constructor(data?: PartialMessage<ReserveStreamExecuteResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.ReserveStreamExecuteResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'error', kind: 'message', T: RPCError },
        { no: 2, name: 'result', kind: 'message', T: QueryResult },
        { no: 3, name: 'reserved_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 4, name: 'tablet_alias', kind: 'message', T: TabletAlias },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ReserveStreamExecuteResponse {
        return new ReserveStreamExecuteResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ReserveStreamExecuteResponse {
        return new ReserveStreamExecuteResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ReserveStreamExecuteResponse {
        return new ReserveStreamExecuteResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: ReserveStreamExecuteResponse | PlainMessage<ReserveStreamExecuteResponse> | undefined,
        b: ReserveStreamExecuteResponse | PlainMessage<ReserveStreamExecuteResponse> | undefined,
    ): boolean {
        return proto3.util.equals(ReserveStreamExecuteResponse, a, b);
    }
}

/**
 * ReserveBeginExecuteRequest is the payload to ReserveBeginExecute
 *
 * @generated from message query.ReserveBeginExecuteRequest
 */
export class ReserveBeginExecuteRequest extends Message<ReserveBeginExecuteRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: query.BoundQuery query = 4;
     */
    query?: BoundQuery;

    /**
     * @generated from field: query.ExecuteOptions options = 5;
     */
    options?: ExecuteOptions;

    /**
     * @generated from field: repeated string pre_queries = 6;
     */
    preQueries: string[] = [];

    /**
     * @generated from field: repeated string post_begin_queries = 7;
     */
    postBeginQueries: string[] = [];

    constructor(data?: PartialMessage<ReserveBeginExecuteRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.ReserveBeginExecuteRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'query', kind: 'message', T: BoundQuery },
        { no: 5, name: 'options', kind: 'message', T: ExecuteOptions },
        {
            no: 6,
            name: 'pre_queries',
            kind: 'scalar',
            T: 9 /* ScalarType.STRING */,
            repeated: true,
        },
        {
            no: 7,
            name: 'post_begin_queries',
            kind: 'scalar',
            T: 9 /* ScalarType.STRING */,
            repeated: true,
        },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ReserveBeginExecuteRequest {
        return new ReserveBeginExecuteRequest().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ReserveBeginExecuteRequest {
        return new ReserveBeginExecuteRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ReserveBeginExecuteRequest {
        return new ReserveBeginExecuteRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: ReserveBeginExecuteRequest | PlainMessage<ReserveBeginExecuteRequest> | undefined,
        b: ReserveBeginExecuteRequest | PlainMessage<ReserveBeginExecuteRequest> | undefined,
    ): boolean {
        return proto3.util.equals(ReserveBeginExecuteRequest, a, b);
    }
}

/**
 * ReserveBeginExecuteResponse is the returned value from ReserveBeginExecute
 *
 * @generated from message query.ReserveBeginExecuteResponse
 */
export class ReserveBeginExecuteResponse extends Message<ReserveBeginExecuteResponse> {
    /**
     * error contains an application level error if necessary. Note the
     * transaction_id may be set, even when an error is returned, if the begin
     * worked but the execute failed.
     *
     * @generated from field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;

    /**
     * @generated from field: query.QueryResult result = 2;
     */
    result?: QueryResult;

    /**
     * The following fields might be non-zero even if an error is present.
     *
     * @generated from field: int64 transaction_id = 3;
     */
    transactionId = protoInt64.zero;

    /**
     * @generated from field: int64 reserved_id = 4;
     */
    reservedId = protoInt64.zero;

    /**
     * @generated from field: topodata.TabletAlias tablet_alias = 5;
     */
    tabletAlias?: TabletAlias;

    /**
     * The session_state_changes might be set if the transaction is a snapshot transaction
     * and the MySQL implementation supports getting a start gtid on snapshot
     *
     * @generated from field: string session_state_changes = 6;
     */
    sessionStateChanges = '';

    constructor(data?: PartialMessage<ReserveBeginExecuteResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.ReserveBeginExecuteResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'error', kind: 'message', T: RPCError },
        { no: 2, name: 'result', kind: 'message', T: QueryResult },
        { no: 3, name: 'transaction_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 4, name: 'reserved_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 5, name: 'tablet_alias', kind: 'message', T: TabletAlias },
        { no: 6, name: 'session_state_changes', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ReserveBeginExecuteResponse {
        return new ReserveBeginExecuteResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ReserveBeginExecuteResponse {
        return new ReserveBeginExecuteResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ReserveBeginExecuteResponse {
        return new ReserveBeginExecuteResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: ReserveBeginExecuteResponse | PlainMessage<ReserveBeginExecuteResponse> | undefined,
        b: ReserveBeginExecuteResponse | PlainMessage<ReserveBeginExecuteResponse> | undefined,
    ): boolean {
        return proto3.util.equals(ReserveBeginExecuteResponse, a, b);
    }
}

/**
 * ReserveBeginStreamExecuteRequest is the payload to ReserveBeginStreamExecute
 *
 * @generated from message query.ReserveBeginStreamExecuteRequest
 */
export class ReserveBeginStreamExecuteRequest extends Message<ReserveBeginStreamExecuteRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: query.BoundQuery query = 4;
     */
    query?: BoundQuery;

    /**
     * @generated from field: query.ExecuteOptions options = 5;
     */
    options?: ExecuteOptions;

    /**
     * @generated from field: repeated string pre_queries = 6;
     */
    preQueries: string[] = [];

    /**
     * @generated from field: repeated string post_begin_queries = 7;
     */
    postBeginQueries: string[] = [];

    constructor(data?: PartialMessage<ReserveBeginStreamExecuteRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.ReserveBeginStreamExecuteRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'query', kind: 'message', T: BoundQuery },
        { no: 5, name: 'options', kind: 'message', T: ExecuteOptions },
        {
            no: 6,
            name: 'pre_queries',
            kind: 'scalar',
            T: 9 /* ScalarType.STRING */,
            repeated: true,
        },
        {
            no: 7,
            name: 'post_begin_queries',
            kind: 'scalar',
            T: 9 /* ScalarType.STRING */,
            repeated: true,
        },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ReserveBeginStreamExecuteRequest {
        return new ReserveBeginStreamExecuteRequest().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ReserveBeginStreamExecuteRequest {
        return new ReserveBeginStreamExecuteRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ReserveBeginStreamExecuteRequest {
        return new ReserveBeginStreamExecuteRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a:
            | ReserveBeginStreamExecuteRequest
            | PlainMessage<ReserveBeginStreamExecuteRequest>
            | undefined,
        b:
            | ReserveBeginStreamExecuteRequest
            | PlainMessage<ReserveBeginStreamExecuteRequest>
            | undefined,
    ): boolean {
        return proto3.util.equals(ReserveBeginStreamExecuteRequest, a, b);
    }
}

/**
 * ReserveBeginStreamExecuteResponse is the returned value from ReserveBeginStreamExecute
 *
 * @generated from message query.ReserveBeginStreamExecuteResponse
 */
export class ReserveBeginStreamExecuteResponse extends Message<ReserveBeginStreamExecuteResponse> {
    /**
     * error contains an application level error if necessary. Note the
     * transaction_id may be set, even when an error is returned, if the begin
     * worked but the stream execute failed.
     *
     * @generated from field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;

    /**
     * @generated from field: query.QueryResult result = 2;
     */
    result?: QueryResult;

    /**
     * The following fields might be non-zero even if an error is present.
     *
     * @generated from field: int64 transaction_id = 3;
     */
    transactionId = protoInt64.zero;

    /**
     * @generated from field: int64 reserved_id = 4;
     */
    reservedId = protoInt64.zero;

    /**
     * @generated from field: topodata.TabletAlias tablet_alias = 5;
     */
    tabletAlias?: TabletAlias;

    /**
     * The session_state_changes might be set if the transaction is a snapshot transaction
     * and the MySQL implementation supports getting a start gtid on snapshot
     *
     * @generated from field: string session_state_changes = 6;
     */
    sessionStateChanges = '';

    constructor(data?: PartialMessage<ReserveBeginStreamExecuteResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.ReserveBeginStreamExecuteResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'error', kind: 'message', T: RPCError },
        { no: 2, name: 'result', kind: 'message', T: QueryResult },
        { no: 3, name: 'transaction_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 4, name: 'reserved_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 5, name: 'tablet_alias', kind: 'message', T: TabletAlias },
        { no: 6, name: 'session_state_changes', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ReserveBeginStreamExecuteResponse {
        return new ReserveBeginStreamExecuteResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ReserveBeginStreamExecuteResponse {
        return new ReserveBeginStreamExecuteResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ReserveBeginStreamExecuteResponse {
        return new ReserveBeginStreamExecuteResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a:
            | ReserveBeginStreamExecuteResponse
            | PlainMessage<ReserveBeginStreamExecuteResponse>
            | undefined,
        b:
            | ReserveBeginStreamExecuteResponse
            | PlainMessage<ReserveBeginStreamExecuteResponse>
            | undefined,
    ): boolean {
        return proto3.util.equals(ReserveBeginStreamExecuteResponse, a, b);
    }
}

/**
 * ReleaseRequest is the payload to Release
 *
 * @generated from message query.ReleaseRequest
 */
export class ReleaseRequest extends Message<ReleaseRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: int64 transaction_id = 4;
     */
    transactionId = protoInt64.zero;

    /**
     * @generated from field: int64 reserved_id = 5;
     */
    reservedId = protoInt64.zero;

    constructor(data?: PartialMessage<ReleaseRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.ReleaseRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'transaction_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 5, name: 'reserved_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReleaseRequest {
        return new ReleaseRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReleaseRequest {
        return new ReleaseRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReleaseRequest {
        return new ReleaseRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: ReleaseRequest | PlainMessage<ReleaseRequest> | undefined,
        b: ReleaseRequest | PlainMessage<ReleaseRequest> | undefined,
    ): boolean {
        return proto3.util.equals(ReleaseRequest, a, b);
    }
}

/**
 * ReleaseResponse is the returned value from Release
 *
 * @generated from message query.ReleaseResponse
 */
export class ReleaseResponse extends Message<ReleaseResponse> {
    constructor(data?: PartialMessage<ReleaseResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.ReleaseResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => []);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReleaseResponse {
        return new ReleaseResponse().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReleaseResponse {
        return new ReleaseResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReleaseResponse {
        return new ReleaseResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: ReleaseResponse | PlainMessage<ReleaseResponse> | undefined,
        b: ReleaseResponse | PlainMessage<ReleaseResponse> | undefined,
    ): boolean {
        return proto3.util.equals(ReleaseResponse, a, b);
    }
}

/**
 * StreamHealthRequest is the payload for StreamHealth
 *
 * @generated from message query.StreamHealthRequest
 */
export class StreamHealthRequest extends Message<StreamHealthRequest> {
    constructor(data?: PartialMessage<StreamHealthRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.StreamHealthRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => []);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): StreamHealthRequest {
        return new StreamHealthRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamHealthRequest {
        return new StreamHealthRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): StreamHealthRequest {
        return new StreamHealthRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: StreamHealthRequest | PlainMessage<StreamHealthRequest> | undefined,
        b: StreamHealthRequest | PlainMessage<StreamHealthRequest> | undefined,
    ): boolean {
        return proto3.util.equals(StreamHealthRequest, a, b);
    }
}

/**
 * RealtimeStats contains information about the tablet status.
 * It is only valid for a single tablet.
 *
 * @generated from message query.RealtimeStats
 */
export class RealtimeStats extends Message<RealtimeStats> {
    /**
     * health_error is the last error we got from health check,
     * or empty is the server is healthy. This is used for subset selection,
     * we do not send queries to servers that are not healthy.
     *
     * @generated from field: string health_error = 1;
     */
    healthError = '';

    /**
     * replication_lag_seconds is populated for replicas only. It indicates
     * how far behind on (MySQL) replication a replica currently is.  It is used
     * by clients for subset selection (so we don't try to send traffic
     * to tablets that are too far behind).
     * NOTE: This field must not be evaluated if "health_error" is not empty.
     * TODO(mberlin): Let's switch it to int64 instead?
     *
     * @generated from field: uint32 replication_lag_seconds = 2;
     */
    replicationLagSeconds = 0;

    /**
     * bin_log_players_count is the number of currently running binlog players.
     * if the value is 0, it means that filtered replication is currently not
     * running on the tablet. If >0, filtered replication is running.
     * NOTE: This field must not be evaluated if "health_error" is not empty.
     *
     * @generated from field: int32 binlog_players_count = 3;
     */
    binlogPlayersCount = 0;

    /**
     * filtered_replication_lag_seconds is populated for the receiving
     * primary of an ongoing filtered replication only.
     * It specifies how far the receiving primary lags behind the sending primary.
     * NOTE: This field must not be evaluated if "health_error" is not empty.
     * NOTE: This field must not be evaluated if "bin_log_players_count" is 0.
     *
     * @generated from field: int64 filtered_replication_lag_seconds = 4;
     */
    filteredReplicationLagSeconds = protoInt64.zero;

    /**
     * cpu_usage is used for load-based balancing
     *
     * @generated from field: double cpu_usage = 5;
     */
    cpuUsage = 0;

    /**
     * qps is the average QPS (queries per second) rate in the last XX seconds
     * where XX is usually 60 (See query_service_stats.go).
     *
     * @generated from field: double qps = 6;
     */
    qps = 0;

    /**
     * table_schema_changed is to provide list of tables that have schema changes detected by the tablet.
     *
     * @generated from field: repeated string table_schema_changed = 7;
     */
    tableSchemaChanged: string[] = [];

    /**
     * view_schema_changed is to provide list of views that have schema changes detected by the tablet.
     *
     * @generated from field: repeated string view_schema_changed = 8;
     */
    viewSchemaChanged: string[] = [];

    /**
     * udfs_changed is used to signal that the UDFs have changed on the tablet.
     *
     * @generated from field: bool udfs_changed = 9;
     */
    udfsChanged = false;

    /**
     * @generated from field: bool tx_unresolved = 10;
     */
    txUnresolved = false;

    constructor(data?: PartialMessage<RealtimeStats>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.RealtimeStats';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'health_error', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'replication_lag_seconds', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
        { no: 3, name: 'binlog_players_count', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
        {
            no: 4,
            name: 'filtered_replication_lag_seconds',
            kind: 'scalar',
            T: 3 /* ScalarType.INT64 */,
        },
        { no: 5, name: 'cpu_usage', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
        { no: 6, name: 'qps', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
        {
            no: 7,
            name: 'table_schema_changed',
            kind: 'scalar',
            T: 9 /* ScalarType.STRING */,
            repeated: true,
        },
        {
            no: 8,
            name: 'view_schema_changed',
            kind: 'scalar',
            T: 9 /* ScalarType.STRING */,
            repeated: true,
        },
        { no: 9, name: 'udfs_changed', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        { no: 10, name: 'tx_unresolved', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RealtimeStats {
        return new RealtimeStats().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RealtimeStats {
        return new RealtimeStats().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RealtimeStats {
        return new RealtimeStats().fromJsonString(jsonString, options);
    }

    static equals(
        a: RealtimeStats | PlainMessage<RealtimeStats> | undefined,
        b: RealtimeStats | PlainMessage<RealtimeStats> | undefined,
    ): boolean {
        return proto3.util.equals(RealtimeStats, a, b);
    }
}

/**
 * AggregateStats contains information about the health of a group of
 * tablets for a Target.  It is used to propagate stats from a vtgate
 * to another, or from the Gateway layer of a vtgate to the routing
 * layer.
 *
 * @generated from message query.AggregateStats
 */
export class AggregateStats extends Message<AggregateStats> {
    /**
     * healthy_tablet_count is the number of healthy tablets in the group.
     *
     * @generated from field: int32 healthy_tablet_count = 1;
     */
    healthyTabletCount = 0;

    /**
     * unhealthy_tablet_count is the number of unhealthy tablets in the group.
     *
     * @generated from field: int32 unhealthy_tablet_count = 2;
     */
    unhealthyTabletCount = 0;

    /**
     * replication_lag_seconds_min is the minimum of the
     * replication_lag_seconds values of the healthy tablets. It is unset
     * if the tablet type is primary.
     *
     * @generated from field: uint32 replication_lag_seconds_min = 3;
     */
    replicationLagSecondsMin = 0;

    /**
     * replication_lag_seconds_max is the maximum of the
     * replication_lag_seconds values of the healthy tablets. It is unset
     * if the tablet type is primary.
     *
     * @generated from field: uint32 replication_lag_seconds_max = 4;
     */
    replicationLagSecondsMax = 0;

    constructor(data?: PartialMessage<AggregateStats>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.AggregateStats';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'healthy_tablet_count', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
        { no: 2, name: 'unhealthy_tablet_count', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
        {
            no: 3,
            name: 'replication_lag_seconds_min',
            kind: 'scalar',
            T: 13 /* ScalarType.UINT32 */,
        },
        {
            no: 4,
            name: 'replication_lag_seconds_max',
            kind: 'scalar',
            T: 13 /* ScalarType.UINT32 */,
        },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregateStats {
        return new AggregateStats().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregateStats {
        return new AggregateStats().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregateStats {
        return new AggregateStats().fromJsonString(jsonString, options);
    }

    static equals(
        a: AggregateStats | PlainMessage<AggregateStats> | undefined,
        b: AggregateStats | PlainMessage<AggregateStats> | undefined,
    ): boolean {
        return proto3.util.equals(AggregateStats, a, b);
    }
}

/**
 * StreamHealthResponse is streamed by StreamHealth on a regular basis.
 * It is expected to be used between a vtgate and vttablet:
 * - target describes the tablet.
 * - realtime_stats is set.
 * - aggregate_stats is not set (deprecated)
 *
 * @generated from message query.StreamHealthResponse
 */
export class StreamHealthResponse extends Message<StreamHealthResponse> {
    /**
     * target is the current server type. Only queries with that exact Target
     * record will be accepted (the cell may not match, however).
     *
     * @generated from field: query.Target target = 1;
     */
    target?: Target;

    /**
     * serving is true iff the tablet is serving. A tablet may not be serving
     * if filtered replication is enabled on a primary for instance,
     * or if a replica should not be used because the keyspace is being resharded.
     *
     * @generated from field: bool serving = 2;
     */
    serving = false;

    /**
     * primary_term_start_timestamp can be interpreted as the
     * last time we knew that this tablet was promoted to a PRIMARY of this shard
     * (if StreamHealthResponse describes a group of tablets, between
     * two vtgates, only one primary will be present in the group, and
     * this is this primary's value).
     *
     * It is used by vtgate when determining the current PRIMARY of a shard.
     * If vtgate sees more than one PRIMARY tablet, this timestamp is used
     * as tiebreaker where the PRIMARY with the highest timestamp wins.
     * Another usage of this timestamp is in go/vt/vtgate/buffer to detect the end
     * of a reparent (failover) and stop buffering.
     *
     * In practice, this field is set to:
     * a) the last time the RPC tabletmanager.TabletExternallyReparented was
     *    called on this tablet (usually done by an external failover tool e.g.
     *    Orchestrator). The failover tool can call this as long as we are the
     *    primary i.e. even ages after the last reparent occurred.
     * OR
     * b) the last time an active reparent was executed through a vtctl command
     *    (InitShardPrimary, PlannedReparentShard, EmergencyReparentShard)
     * OR
     * c) the last time vttablet was started and it initialized its tablet type
     *    as PRIMARY because it was recorded as the shard's current primary in the
     *    topology (see go/vt/vttablet/tabletmanager/init_tablet.go)
     * OR
     * d) 0 if the vttablet is not a PRIMARY.
     *
     * @generated from field: int64 primary_term_start_timestamp = 3;
     */
    primaryTermStartTimestamp = protoInt64.zero;

    /**
     * realtime_stats contains information about the tablet status.
     * It is only filled in if the information is about a tablet.
     *
     * @generated from field: query.RealtimeStats realtime_stats = 4;
     */
    realtimeStats?: RealtimeStats;

    /**
     * tablet_alias is the alias of the sending tablet. The discovery/healthcheck.go
     * code uses it to verify that it's talking to the correct tablet and that it
     * hasn't changed in the meantime e.g. due to tablet restarts where ports or
     * ips have been reused but assigned differently.
     *
     * @generated from field: topodata.TabletAlias tablet_alias = 5;
     */
    tabletAlias?: TabletAlias;

    constructor(data?: PartialMessage<StreamHealthResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.StreamHealthResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'target', kind: 'message', T: Target },
        { no: 2, name: 'serving', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        {
            no: 3,
            name: 'primary_term_start_timestamp',
            kind: 'scalar',
            T: 3 /* ScalarType.INT64 */,
        },
        { no: 4, name: 'realtime_stats', kind: 'message', T: RealtimeStats },
        { no: 5, name: 'tablet_alias', kind: 'message', T: TabletAlias },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): StreamHealthResponse {
        return new StreamHealthResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): StreamHealthResponse {
        return new StreamHealthResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): StreamHealthResponse {
        return new StreamHealthResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: StreamHealthResponse | PlainMessage<StreamHealthResponse> | undefined,
        b: StreamHealthResponse | PlainMessage<StreamHealthResponse> | undefined,
    ): boolean {
        return proto3.util.equals(StreamHealthResponse, a, b);
    }
}

/**
 * TransactionMetadata contains the metadata for a distributed transaction.
 *
 * @generated from message query.TransactionMetadata
 */
export class TransactionMetadata extends Message<TransactionMetadata> {
    /**
     * @generated from field: string dtid = 1;
     */
    dtid = '';

    /**
     * @generated from field: query.TransactionState state = 2;
     */
    state = TransactionState.UNKNOWN;

    /**
     * @generated from field: int64 time_created = 3;
     */
    timeCreated = protoInt64.zero;

    /**
     * @generated from field: repeated query.Target participants = 4;
     */
    participants: Target[] = [];

    constructor(data?: PartialMessage<TransactionMetadata>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.TransactionMetadata';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'dtid', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'state', kind: 'enum', T: proto3.getEnumType(TransactionState) },
        { no: 3, name: 'time_created', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 4, name: 'participants', kind: 'message', T: Target, repeated: true },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): TransactionMetadata {
        return new TransactionMetadata().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionMetadata {
        return new TransactionMetadata().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): TransactionMetadata {
        return new TransactionMetadata().fromJsonString(jsonString, options);
    }

    static equals(
        a: TransactionMetadata | PlainMessage<TransactionMetadata> | undefined,
        b: TransactionMetadata | PlainMessage<TransactionMetadata> | undefined,
    ): boolean {
        return proto3.util.equals(TransactionMetadata, a, b);
    }
}

/**
 * GetSchemaRequest is the payload to GetSchema
 *
 * @generated from message query.GetSchemaRequest
 */
export class GetSchemaRequest extends Message<GetSchemaRequest> {
    /**
     * @generated from field: query.Target target = 1;
     */
    target?: Target;

    /**
     * @generated from field: query.SchemaTableType table_type = 2;
     */
    tableType = SchemaTableType.VIEWS;

    /**
     * @generated from field: repeated string table_names = 3;
     */
    tableNames: string[] = [];

    constructor(data?: PartialMessage<GetSchemaRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.GetSchemaRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'target', kind: 'message', T: Target },
        { no: 2, name: 'table_type', kind: 'enum', T: proto3.getEnumType(SchemaTableType) },
        {
            no: 3,
            name: 'table_names',
            kind: 'scalar',
            T: 9 /* ScalarType.STRING */,
            repeated: true,
        },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSchemaRequest {
        return new GetSchemaRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSchemaRequest {
        return new GetSchemaRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): GetSchemaRequest {
        return new GetSchemaRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: GetSchemaRequest | PlainMessage<GetSchemaRequest> | undefined,
        b: GetSchemaRequest | PlainMessage<GetSchemaRequest> | undefined,
    ): boolean {
        return proto3.util.equals(GetSchemaRequest, a, b);
    }
}

/**
 * UDFInfo represents the information about a UDF.
 *
 * @generated from message query.UDFInfo
 */
export class UDFInfo extends Message<UDFInfo> {
    /**
     * @generated from field: string name = 1;
     */
    name = '';

    /**
     * @generated from field: bool aggregating = 2;
     */
    aggregating = false;

    /**
     * @generated from field: query.Type return_type = 3;
     */
    returnType = Type.NULL_TYPE;

    constructor(data?: PartialMessage<UDFInfo>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.UDFInfo';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'aggregating', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        { no: 3, name: 'return_type', kind: 'enum', T: proto3.getEnumType(Type) },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UDFInfo {
        return new UDFInfo().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UDFInfo {
        return new UDFInfo().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UDFInfo {
        return new UDFInfo().fromJsonString(jsonString, options);
    }

    static equals(
        a: UDFInfo | PlainMessage<UDFInfo> | undefined,
        b: UDFInfo | PlainMessage<UDFInfo> | undefined,
    ): boolean {
        return proto3.util.equals(UDFInfo, a, b);
    }
}

/**
 * GetSchemaResponse is the returned value from GetSchema
 *
 * @generated from message query.GetSchemaResponse
 */
export class GetSchemaResponse extends Message<GetSchemaResponse> {
    /**
     * @generated from field: repeated query.UDFInfo udfs = 1;
     */
    udfs: UDFInfo[] = [];

    /**
     * this is for the schema definition for the requested tables and views.
     *
     * @generated from field: map<string, string> table_definition = 2;
     */
    tableDefinition: { [key: string]: string } = {};

    constructor(data?: PartialMessage<GetSchemaResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'query.GetSchemaResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'udfs', kind: 'message', T: UDFInfo, repeated: true },
        {
            no: 2,
            name: 'table_definition',
            kind: 'map',
            K: 9 /* ScalarType.STRING */,
            V: { kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSchemaResponse {
        return new GetSchemaResponse().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSchemaResponse {
        return new GetSchemaResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): GetSchemaResponse {
        return new GetSchemaResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: GetSchemaResponse | PlainMessage<GetSchemaResponse> | undefined,
        b: GetSchemaResponse | PlainMessage<GetSchemaResponse> | undefined,
    ): boolean {
        return proto3.util.equals(GetSchemaResponse, a, b);
    }
}
