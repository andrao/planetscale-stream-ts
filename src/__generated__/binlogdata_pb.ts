//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file contains all the types and servers necessary to make
// RPC calls to VtTablet for the binlog protocol, used by filtered
// replication only.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file binlogdata.proto (package binlogdata, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import {
    Message,
    proto3,
    protoInt64,
    type BinaryReadOptions,
    type FieldList,
    type JsonReadOptions,
    type JsonValue,
    type PartialMessage,
    type PlainMessage,
} from '@bufbuild/protobuf';
import { EventToken, Field, QueryResult, Row, Target, VTGateCallerID } from './query_pb.js';
import { KeyRange, TabletType } from './topodata_pb.js';
import { CallerID } from './vtrpc_pb.js';

/**
 * OnDDLAction lists the possible actions for DDLs.
 *
 * @generated from enum binlogdata.OnDDLAction
 */
export enum OnDDLAction {
    /**
     * @generated from enum value: IGNORE = 0;
     */
    IGNORE = 0,

    /**
     * @generated from enum value: STOP = 1;
     */
    STOP = 1,

    /**
     * @generated from enum value: EXEC = 2;
     */
    EXEC = 2,

    /**
     * @generated from enum value: EXEC_IGNORE = 3;
     */
    EXEC_IGNORE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(OnDDLAction)
proto3.util.setEnumType(OnDDLAction, 'binlogdata.OnDDLAction', [
    { no: 0, name: 'IGNORE' },
    { no: 1, name: 'STOP' },
    { no: 2, name: 'EXEC' },
    { no: 3, name: 'EXEC_IGNORE' },
]);

/**
 * VReplicationWorkflowType define types of vreplication workflows.
 *
 * @generated from enum binlogdata.VReplicationWorkflowType
 */
export enum VReplicationWorkflowType {
    /**
     * @generated from enum value: Materialize = 0;
     */
    Materialize = 0,

    /**
     * @generated from enum value: MoveTables = 1;
     */
    MoveTables = 1,

    /**
     * @generated from enum value: CreateLookupIndex = 2;
     */
    CreateLookupIndex = 2,

    /**
     * @generated from enum value: Migrate = 3;
     */
    Migrate = 3,

    /**
     * @generated from enum value: Reshard = 4;
     */
    Reshard = 4,

    /**
     * @generated from enum value: OnlineDDL = 5;
     */
    OnlineDDL = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(VReplicationWorkflowType)
proto3.util.setEnumType(VReplicationWorkflowType, 'binlogdata.VReplicationWorkflowType', [
    { no: 0, name: 'Materialize' },
    { no: 1, name: 'MoveTables' },
    { no: 2, name: 'CreateLookupIndex' },
    { no: 3, name: 'Migrate' },
    { no: 4, name: 'Reshard' },
    { no: 5, name: 'OnlineDDL' },
]);

/**
 * VReplicationWorkflowSubType define types of vreplication workflows.
 *
 * @generated from enum binlogdata.VReplicationWorkflowSubType
 */
export enum VReplicationWorkflowSubType {
    /**
     * @generated from enum value: None = 0;
     */
    None = 0,

    /**
     * @generated from enum value: Partial = 1;
     */
    Partial = 1,

    /**
     * @generated from enum value: AtomicCopy = 2;
     */
    AtomicCopy = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(VReplicationWorkflowSubType)
proto3.util.setEnumType(VReplicationWorkflowSubType, 'binlogdata.VReplicationWorkflowSubType', [
    { no: 0, name: 'None' },
    { no: 1, name: 'Partial' },
    { no: 2, name: 'AtomicCopy' },
]);

/**
 * VReplicationWorklfowState defines the valid states that a workflow can be in.
 *
 * @generated from enum binlogdata.VReplicationWorkflowState
 */
export enum VReplicationWorkflowState {
    /**
     * @generated from enum value: Unknown = 0;
     */
    Unknown = 0,

    /**
     * @generated from enum value: Init = 1;
     */
    Init = 1,

    /**
     * @generated from enum value: Stopped = 2;
     */
    Stopped = 2,

    /**
     * @generated from enum value: Copying = 3;
     */
    Copying = 3,

    /**
     * @generated from enum value: Running = 4;
     */
    Running = 4,

    /**
     * @generated from enum value: Error = 5;
     */
    Error = 5,

    /**
     * @generated from enum value: Lagging = 6;
     */
    Lagging = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(VReplicationWorkflowState)
proto3.util.setEnumType(VReplicationWorkflowState, 'binlogdata.VReplicationWorkflowState', [
    { no: 0, name: 'Unknown' },
    { no: 1, name: 'Init' },
    { no: 2, name: 'Stopped' },
    { no: 3, name: 'Copying' },
    { no: 4, name: 'Running' },
    { no: 5, name: 'Error' },
    { no: 6, name: 'Lagging' },
]);

/**
 * VEventType enumerates the event types. Many of these types
 * will not be encountered in RBR mode.
 *
 * @generated from enum binlogdata.VEventType
 */
export enum VEventType {
    /**
     * @generated from enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,

    /**
     * @generated from enum value: GTID = 1;
     */
    GTID = 1,

    /**
     * @generated from enum value: BEGIN = 2;
     */
    BEGIN = 2,

    /**
     * @generated from enum value: COMMIT = 3;
     */
    COMMIT = 3,

    /**
     * @generated from enum value: ROLLBACK = 4;
     */
    ROLLBACK = 4,

    /**
     * @generated from enum value: DDL = 5;
     */
    DDL = 5,

    /**
     * INSERT, REPLACE, UPDATE, DELETE and SET will not be seen in RBR mode.
     *
     * @generated from enum value: INSERT = 6;
     */
    INSERT = 6,

    /**
     * @generated from enum value: REPLACE = 7;
     */
    REPLACE = 7,

    /**
     * @generated from enum value: UPDATE = 8;
     */
    UPDATE = 8,

    /**
     * @generated from enum value: DELETE = 9;
     */
    DELETE = 9,

    /**
     * @generated from enum value: SET = 10;
     */
    SET = 10,

    /**
     * OTHER is a dummy event. If encountered, the current GTID must be
     * recorded by the client to be able to resume.
     *
     * @generated from enum value: OTHER = 11;
     */
    OTHER = 11,

    /**
     * @generated from enum value: ROW = 12;
     */
    ROW = 12,

    /**
     * @generated from enum value: FIELD = 13;
     */
    FIELD = 13,

    /**
     * HEARTBEAT is sent if there is inactivity. If a client does not
     * receive events beyond the hearbeat interval, it can assume that it's
     * lost connection to the vstreamer.
     *
     * @generated from enum value: HEARTBEAT = 14;
     */
    HEARTBEAT = 14,

    /**
     * VGTID is generated by VTGate's VStream that combines multiple
     * GTIDs.
     *
     * @generated from enum value: VGTID = 15;
     */
    VGTID = 15,

    /**
     * @generated from enum value: JOURNAL = 16;
     */
    JOURNAL = 16,

    /**
     * @generated from enum value: VERSION = 17;
     */
    VERSION = 17,

    /**
     * @generated from enum value: LASTPK = 18;
     */
    LASTPK = 18,

    /**
     * @generated from enum value: SAVEPOINT = 19;
     */
    SAVEPOINT = 19,

    /**
     * COPY_COMPLETED is sent when VTGate's VStream copy operation is done.
     * If a client experiences some disruptions before receiving the event,
     * the client should restart the copy operation.
     *
     * @generated from enum value: COPY_COMPLETED = 20;
     */
    COPY_COMPLETED = 20,
}
// Retrieve enum metadata with: proto3.getEnumType(VEventType)
proto3.util.setEnumType(VEventType, 'binlogdata.VEventType', [
    { no: 0, name: 'UNKNOWN' },
    { no: 1, name: 'GTID' },
    { no: 2, name: 'BEGIN' },
    { no: 3, name: 'COMMIT' },
    { no: 4, name: 'ROLLBACK' },
    { no: 5, name: 'DDL' },
    { no: 6, name: 'INSERT' },
    { no: 7, name: 'REPLACE' },
    { no: 8, name: 'UPDATE' },
    { no: 9, name: 'DELETE' },
    { no: 10, name: 'SET' },
    { no: 11, name: 'OTHER' },
    { no: 12, name: 'ROW' },
    { no: 13, name: 'FIELD' },
    { no: 14, name: 'HEARTBEAT' },
    { no: 15, name: 'VGTID' },
    { no: 16, name: 'JOURNAL' },
    { no: 17, name: 'VERSION' },
    { no: 18, name: 'LASTPK' },
    { no: 19, name: 'SAVEPOINT' },
    { no: 20, name: 'COPY_COMPLETED' },
]);

/**
 * MigrationType specifies the type of migration for the Journal.
 *
 * @generated from enum binlogdata.MigrationType
 */
export enum MigrationType {
    /**
     * @generated from enum value: TABLES = 0;
     */
    TABLES = 0,

    /**
     * @generated from enum value: SHARDS = 1;
     */
    SHARDS = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(MigrationType)
proto3.util.setEnumType(MigrationType, 'binlogdata.MigrationType', [
    { no: 0, name: 'TABLES' },
    { no: 1, name: 'SHARDS' },
]);

/**
 * Charset is the per-statement charset info from a QUERY_EVENT binlog entry.
 *
 * @generated from message binlogdata.Charset
 */
export class Charset extends Message<Charset> {
    /**
     * @@session.character_set_client
     *
     * @generated from field: int32 client = 1;
     */
    client = 0;

    /**
     * @@session.collation_connection
     *
     * @generated from field: int32 conn = 2;
     */
    conn = 0;

    /**
     * @@session.collation_server
     *
     * @generated from field: int32 server = 3;
     */
    server = 0;

    constructor(data?: PartialMessage<Charset>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.Charset';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'client', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
        { no: 2, name: 'conn', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
        { no: 3, name: 'server', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Charset {
        return new Charset().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Charset {
        return new Charset().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Charset {
        return new Charset().fromJsonString(jsonString, options);
    }

    static equals(
        a: Charset | PlainMessage<Charset> | undefined,
        b: Charset | PlainMessage<Charset> | undefined,
    ): boolean {
        return proto3.util.equals(Charset, a, b);
    }
}

/**
 * BinlogTransaction describes a transaction inside the binlogs.
 * It is streamed by vttablet for filtered replication, used during resharding.
 *
 * @generated from message binlogdata.BinlogTransaction
 */
export class BinlogTransaction extends Message<BinlogTransaction> {
    /**
     * the statements in this transaction
     *
     * @generated from field: repeated binlogdata.BinlogTransaction.Statement statements = 1;
     */
    statements: BinlogTransaction_Statement[] = [];

    /**
     * The Event Token for this event.
     *
     * @generated from field: query.EventToken event_token = 4;
     */
    eventToken?: EventToken;

    constructor(data?: PartialMessage<BinlogTransaction>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.BinlogTransaction';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        {
            no: 1,
            name: 'statements',
            kind: 'message',
            T: BinlogTransaction_Statement,
            repeated: true,
        },
        { no: 4, name: 'event_token', kind: 'message', T: EventToken },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BinlogTransaction {
        return new BinlogTransaction().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BinlogTransaction {
        return new BinlogTransaction().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): BinlogTransaction {
        return new BinlogTransaction().fromJsonString(jsonString, options);
    }

    static equals(
        a: BinlogTransaction | PlainMessage<BinlogTransaction> | undefined,
        b: BinlogTransaction | PlainMessage<BinlogTransaction> | undefined,
    ): boolean {
        return proto3.util.equals(BinlogTransaction, a, b);
    }
}

/**
 * @generated from message binlogdata.BinlogTransaction.Statement
 */
export class BinlogTransaction_Statement extends Message<BinlogTransaction_Statement> {
    /**
     * what type of statement is this?
     *
     * @generated from field: binlogdata.BinlogTransaction.Statement.Category category = 1;
     */
    category = BinlogTransaction_Statement_Category.BL_UNRECOGNIZED;

    /**
     * charset of this statement, if different from pre-negotiated default.
     *
     * @generated from field: binlogdata.Charset charset = 2;
     */
    charset?: Charset;

    /**
     * the sql
     *
     * @generated from field: bytes sql = 3;
     */
    sql = new Uint8Array(0);

    constructor(data?: PartialMessage<BinlogTransaction_Statement>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.BinlogTransaction.Statement';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        {
            no: 1,
            name: 'category',
            kind: 'enum',
            T: proto3.getEnumType(BinlogTransaction_Statement_Category),
        },
        { no: 2, name: 'charset', kind: 'message', T: Charset },
        { no: 3, name: 'sql', kind: 'scalar', T: 12 /* ScalarType.BYTES */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): BinlogTransaction_Statement {
        return new BinlogTransaction_Statement().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): BinlogTransaction_Statement {
        return new BinlogTransaction_Statement().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): BinlogTransaction_Statement {
        return new BinlogTransaction_Statement().fromJsonString(jsonString, options);
    }

    static equals(
        a: BinlogTransaction_Statement | PlainMessage<BinlogTransaction_Statement> | undefined,
        b: BinlogTransaction_Statement | PlainMessage<BinlogTransaction_Statement> | undefined,
    ): boolean {
        return proto3.util.equals(BinlogTransaction_Statement, a, b);
    }
}

/**
 * @generated from enum binlogdata.BinlogTransaction.Statement.Category
 */
export enum BinlogTransaction_Statement_Category {
    /**
     * @generated from enum value: BL_UNRECOGNIZED = 0;
     */
    BL_UNRECOGNIZED = 0,

    /**
     * @generated from enum value: BL_BEGIN = 1;
     */
    BL_BEGIN = 1,

    /**
     * @generated from enum value: BL_COMMIT = 2;
     */
    BL_COMMIT = 2,

    /**
     * @generated from enum value: BL_ROLLBACK = 3;
     */
    BL_ROLLBACK = 3,

    /**
     * BL_DML is deprecated.
     *
     * @generated from enum value: BL_DML_DEPRECATED = 4;
     */
    BL_DML_DEPRECATED = 4,

    /**
     * @generated from enum value: BL_DDL = 5;
     */
    BL_DDL = 5,

    /**
     * @generated from enum value: BL_SET = 6;
     */
    BL_SET = 6,

    /**
     * @generated from enum value: BL_INSERT = 7;
     */
    BL_INSERT = 7,

    /**
     * @generated from enum value: BL_UPDATE = 8;
     */
    BL_UPDATE = 8,

    /**
     * @generated from enum value: BL_DELETE = 9;
     */
    BL_DELETE = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(BinlogTransaction_Statement_Category)
proto3.util.setEnumType(
    BinlogTransaction_Statement_Category,
    'binlogdata.BinlogTransaction.Statement.Category',
    [
        { no: 0, name: 'BL_UNRECOGNIZED' },
        { no: 1, name: 'BL_BEGIN' },
        { no: 2, name: 'BL_COMMIT' },
        { no: 3, name: 'BL_ROLLBACK' },
        { no: 4, name: 'BL_DML_DEPRECATED' },
        { no: 5, name: 'BL_DDL' },
        { no: 6, name: 'BL_SET' },
        { no: 7, name: 'BL_INSERT' },
        { no: 8, name: 'BL_UPDATE' },
        { no: 9, name: 'BL_DELETE' },
    ],
);

/**
 * StreamKeyRangeRequest is the payload to StreamKeyRange
 *
 * @generated from message binlogdata.StreamKeyRangeRequest
 */
export class StreamKeyRangeRequest extends Message<StreamKeyRangeRequest> {
    /**
     * where to start
     *
     * @generated from field: string position = 1;
     */
    position = '';

    /**
     * what to get
     *
     * @generated from field: topodata.KeyRange key_range = 2;
     */
    keyRange?: KeyRange;

    /**
     * default charset on the player side
     *
     * @generated from field: binlogdata.Charset charset = 3;
     */
    charset?: Charset;

    constructor(data?: PartialMessage<StreamKeyRangeRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.StreamKeyRangeRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'position', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'key_range', kind: 'message', T: KeyRange },
        { no: 3, name: 'charset', kind: 'message', T: Charset },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): StreamKeyRangeRequest {
        return new StreamKeyRangeRequest().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): StreamKeyRangeRequest {
        return new StreamKeyRangeRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): StreamKeyRangeRequest {
        return new StreamKeyRangeRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: StreamKeyRangeRequest | PlainMessage<StreamKeyRangeRequest> | undefined,
        b: StreamKeyRangeRequest | PlainMessage<StreamKeyRangeRequest> | undefined,
    ): boolean {
        return proto3.util.equals(StreamKeyRangeRequest, a, b);
    }
}

/**
 * StreamKeyRangeResponse is the response from StreamKeyRange
 *
 * @generated from message binlogdata.StreamKeyRangeResponse
 */
export class StreamKeyRangeResponse extends Message<StreamKeyRangeResponse> {
    /**
     * @generated from field: binlogdata.BinlogTransaction binlog_transaction = 1;
     */
    binlogTransaction?: BinlogTransaction;

    constructor(data?: PartialMessage<StreamKeyRangeResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.StreamKeyRangeResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'binlog_transaction', kind: 'message', T: BinlogTransaction },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): StreamKeyRangeResponse {
        return new StreamKeyRangeResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): StreamKeyRangeResponse {
        return new StreamKeyRangeResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): StreamKeyRangeResponse {
        return new StreamKeyRangeResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: StreamKeyRangeResponse | PlainMessage<StreamKeyRangeResponse> | undefined,
        b: StreamKeyRangeResponse | PlainMessage<StreamKeyRangeResponse> | undefined,
    ): boolean {
        return proto3.util.equals(StreamKeyRangeResponse, a, b);
    }
}

/**
 * StreamTablesRequest is the payload to StreamTables
 *
 * @generated from message binlogdata.StreamTablesRequest
 */
export class StreamTablesRequest extends Message<StreamTablesRequest> {
    /**
     * where to start
     *
     * @generated from field: string position = 1;
     */
    position = '';

    /**
     * what to get
     *
     * @generated from field: repeated string tables = 2;
     */
    tables: string[] = [];

    /**
     * default charset on the player side
     *
     * @generated from field: binlogdata.Charset charset = 3;
     */
    charset?: Charset;

    constructor(data?: PartialMessage<StreamTablesRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.StreamTablesRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'position', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'tables', kind: 'scalar', T: 9 /* ScalarType.STRING */, repeated: true },
        { no: 3, name: 'charset', kind: 'message', T: Charset },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): StreamTablesRequest {
        return new StreamTablesRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamTablesRequest {
        return new StreamTablesRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): StreamTablesRequest {
        return new StreamTablesRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: StreamTablesRequest | PlainMessage<StreamTablesRequest> | undefined,
        b: StreamTablesRequest | PlainMessage<StreamTablesRequest> | undefined,
    ): boolean {
        return proto3.util.equals(StreamTablesRequest, a, b);
    }
}

/**
 * StreamTablesResponse is the response from StreamTables
 *
 * @generated from message binlogdata.StreamTablesResponse
 */
export class StreamTablesResponse extends Message<StreamTablesResponse> {
    /**
     * @generated from field: binlogdata.BinlogTransaction binlog_transaction = 1;
     */
    binlogTransaction?: BinlogTransaction;

    constructor(data?: PartialMessage<StreamTablesResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.StreamTablesResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'binlog_transaction', kind: 'message', T: BinlogTransaction },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): StreamTablesResponse {
        return new StreamTablesResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): StreamTablesResponse {
        return new StreamTablesResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): StreamTablesResponse {
        return new StreamTablesResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: StreamTablesResponse | PlainMessage<StreamTablesResponse> | undefined,
        b: StreamTablesResponse | PlainMessage<StreamTablesResponse> | undefined,
    ): boolean {
        return proto3.util.equals(StreamTablesResponse, a, b);
    }
}

/**
 * CharsetConversion represent a conversion of text from one charset to another
 *
 * @generated from message binlogdata.CharsetConversion
 */
export class CharsetConversion extends Message<CharsetConversion> {
    /**
     * FromCharset is the charset name from which we convert the text (e.g. latin1)
     *
     * @generated from field: string from_charset = 1;
     */
    fromCharset = '';

    /**
     * ToCharset is the charset name to which we convert the text (e.g. utf8mb4)
     *
     * @generated from field: string to_charset = 2;
     */
    toCharset = '';

    constructor(data?: PartialMessage<CharsetConversion>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.CharsetConversion';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'from_charset', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'to_charset', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CharsetConversion {
        return new CharsetConversion().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CharsetConversion {
        return new CharsetConversion().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): CharsetConversion {
        return new CharsetConversion().fromJsonString(jsonString, options);
    }

    static equals(
        a: CharsetConversion | PlainMessage<CharsetConversion> | undefined,
        b: CharsetConversion | PlainMessage<CharsetConversion> | undefined,
    ): boolean {
        return proto3.util.equals(CharsetConversion, a, b);
    }
}

/**
 * Rule represents one rule in a Filter.
 *
 * @generated from message binlogdata.Rule
 */
export class Rule extends Message<Rule> {
    /**
     * Match can be a table name or a regular expression.
     * If it starts with a '/', it's a regular expression.
     * For example, "t" matches a table named "t", whereas
     * "/t.*" matches all tables that begin with 't'.
     *
     * @generated from field: string match = 1;
     */
    match = '';

    /**
     * Filter: If empty, all columns and rows of the matching tables
     * are sent. If it's a keyrange like "-80", only rows that
     * match the keyrange are sent.
     * If Match is a table name instead of a regular expression,
     * the Filter can also be a select expression like this:
     * "select * from t", same as an empty Filter, or
     * "select * from t where in_keyrange('-80')", same as "-80", or
     * "select col1, col2 from t where in_keyrange(col1, 'hash', '-80'), or
     * What is allowed in a select expression depends on whether
     * it's a vstreamer or vreplication request. For more details,
     * please refer to the specific package documentation.
     * On the vreplication side, Filter can also accept a special
     * "exclude" value, which will cause the matched tables
     * to be excluded.
     * TODO(sougou): support this on vstreamer side also.
     *
     * ConvertEnumToText: optional, list per enum column name, the list of textual values.
     * When reading the binary log, all enum values are numeric. But sometimes it
     * is useful/needed to know what the textual mapping are.
     * Online DDL provides such use case.
     *
     * @generated from field: string filter = 2;
     */
    filter = '';

    /**
     * Example: key="color", value="'red','green','blue'"
     *
     * @generated from field: map<string, string> convert_enum_to_text = 3;
     */
    convertEnumToText: { [key: string]: string } = {};

    /**
     * ConvertCharset: optional mapping, between column name and a CharsetConversion.
     * This hints to vreplication that columns are encoded from/to non-trivial charsets
     * The map is only populated when either "from" or "to" charset of a column are non-trivial
     * trivial charsets are utf8 and ascii variants.
     *
     * @generated from field: map<string, binlogdata.CharsetConversion> convert_charset = 4;
     */
    convertCharset: { [key: string]: CharsetConversion } = {};

    /**
     * SourceUniqueKeyColumns represents the ordered columns in the index used by rowstreamer to iterate the table
     * It is comma delimited, as in col1,col2,col3 (tokens are escaped via net/url)
     *
     * @generated from field: string source_unique_key_columns = 5;
     */
    sourceUniqueKeyColumns = '';

    /**
     * TargetUniqueKeyColumns represents the ordered columns in that index used by vcopier and vplayer to apply rows
     * It is comma delimited, as in col1,col2,col3 (tokens are escaped via net/url)
     *
     * @generated from field: string target_unique_key_columns = 6;
     */
    targetUniqueKeyColumns = '';

    /**
     * SourceUniqueKeyTargetColumns represents the names of columns in target table, mapped from the chosen unique
     * key on source tables (some columns may be renamed from source to target)
     *
     * @generated from field: string source_unique_key_target_columns = 7;
     */
    sourceUniqueKeyTargetColumns = '';

    /**
     * ConvertIntToEnum lists any columns that are converted from an integral value into an enum.
     * such columns need to have special transofrmation of the data, from an integral format into a
     * string format. e.g. the value 0 needs to be converted to '0'.
     *
     * @generated from field: map<string, bool> convert_int_to_enum = 8;
     */
    convertIntToEnum: { [key: string]: boolean } = {};

    /**
     * ForceUniqueKey gives vtreamer a hint for `FORCE INDEX (...)` usage.
     *
     * @generated from field: string force_unique_key = 9;
     */
    forceUniqueKey = '';

    constructor(data?: PartialMessage<Rule>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.Rule';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'match', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'filter', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        {
            no: 3,
            name: 'convert_enum_to_text',
            kind: 'map',
            K: 9 /* ScalarType.STRING */,
            V: { kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        },
        {
            no: 4,
            name: 'convert_charset',
            kind: 'map',
            K: 9 /* ScalarType.STRING */,
            V: { kind: 'message', T: CharsetConversion },
        },
        { no: 5, name: 'source_unique_key_columns', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 6, name: 'target_unique_key_columns', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        {
            no: 7,
            name: 'source_unique_key_target_columns',
            kind: 'scalar',
            T: 9 /* ScalarType.STRING */,
        },
        {
            no: 8,
            name: 'convert_int_to_enum',
            kind: 'map',
            K: 9 /* ScalarType.STRING */,
            V: { kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        },
        { no: 9, name: 'force_unique_key', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Rule {
        return new Rule().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rule {
        return new Rule().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Rule {
        return new Rule().fromJsonString(jsonString, options);
    }

    static equals(
        a: Rule | PlainMessage<Rule> | undefined,
        b: Rule | PlainMessage<Rule> | undefined,
    ): boolean {
        return proto3.util.equals(Rule, a, b);
    }
}

/**
 * Filter represents a list of ordered rules. The first
 * match wins.
 *
 * @generated from message binlogdata.Filter
 */
export class Filter extends Message<Filter> {
    /**
     * @generated from field: repeated binlogdata.Rule rules = 1;
     */
    rules: Rule[] = [];

    /**
     * FieldEventMode specifies the behavior if there is a mismatch
     * between the current schema and the fields in the binlog. This
     * can happen if the binlog position is before a DDL that would
     * cause the fields to change. If vstreamer detects such
     * an inconsistency, the behavior depends on the FieldEventMode.
     * If the value is ERR_ON_MISMATCH (default), then it errors out.
     * If it's BEST_EFFORT, it sends a field event with fake column
     * names as "@1", "@2", etc.
     *
     * @generated from field: binlogdata.Filter.FieldEventMode field_event_mode = 2;
     */
    fieldEventMode = Filter_FieldEventMode.ERR_ON_MISMATCH;

    /**
     * @generated from field: int64 workflow_type = 3;
     */
    workflowType = protoInt64.zero;

    /**
     * @generated from field: string workflow_name = 4;
     */
    workflowName = '';

    constructor(data?: PartialMessage<Filter>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.Filter';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'rules', kind: 'message', T: Rule, repeated: true },
        {
            no: 2,
            name: 'field_event_mode',
            kind: 'enum',
            T: proto3.getEnumType(Filter_FieldEventMode),
        },
        { no: 3, name: 'workflow_type', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 4, name: 'workflow_name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Filter {
        return new Filter().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Filter {
        return new Filter().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Filter {
        return new Filter().fromJsonString(jsonString, options);
    }

    static equals(
        a: Filter | PlainMessage<Filter> | undefined,
        b: Filter | PlainMessage<Filter> | undefined,
    ): boolean {
        return proto3.util.equals(Filter, a, b);
    }
}

/**
 * @generated from enum binlogdata.Filter.FieldEventMode
 */
export enum Filter_FieldEventMode {
    /**
     * @generated from enum value: ERR_ON_MISMATCH = 0;
     */
    ERR_ON_MISMATCH = 0,

    /**
     * @generated from enum value: BEST_EFFORT = 1;
     */
    BEST_EFFORT = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(Filter_FieldEventMode)
proto3.util.setEnumType(Filter_FieldEventMode, 'binlogdata.Filter.FieldEventMode', [
    { no: 0, name: 'ERR_ON_MISMATCH' },
    { no: 1, name: 'BEST_EFFORT' },
]);

/**
 * BinlogSource specifies the source  and filter parameters for
 * Filtered Replication. KeyRange and Tables are legacy. Filter
 * is the new way to specify the filtering rules.
 *
 * @generated from message binlogdata.BinlogSource
 */
export class BinlogSource extends Message<BinlogSource> {
    /**
     * the source keyspace
     *
     * @generated from field: string keyspace = 1;
     */
    keyspace = '';

    /**
     * the source shard
     *
     * @generated from field: string shard = 2;
     */
    shard = '';

    /**
     * the source tablet type
     *
     * @generated from field: topodata.TabletType tablet_type = 3;
     */
    tabletType = TabletType.UNKNOWN;

    /**
     * KeyRange is set if the request is for a keyrange
     *
     * @generated from field: topodata.KeyRange key_range = 4;
     */
    keyRange?: KeyRange;

    /**
     * Tables is set if the request is for a list of tables
     *
     * @generated from field: repeated string tables = 5;
     */
    tables: string[] = [];

    /**
     * Filter is set if we're using the generalized representation
     * for the filter.
     *
     * @generated from field: binlogdata.Filter filter = 6;
     */
    filter?: Filter;

    /**
     * OnDdl specifies the action to be taken when a DDL is encountered.
     *
     * @generated from field: binlogdata.OnDDLAction on_ddl = 7;
     */
    onDdl = OnDDLAction.IGNORE;

    /**
     * Source is an external mysql. This attribute should be set to the username
     * to use in the connection
     *
     * @generated from field: string external_mysql = 8;
     */
    externalMysql = '';

    /**
     * StopAfterCopy specifies if vreplication should be stopped
     * after copying is done.
     *
     * @generated from field: bool stop_after_copy = 9;
     */
    stopAfterCopy = false;

    /**
     * ExternalCluster is the name of the mounted cluster which has the source keyspace/db for this workflow
     * it is of the type <cluster_type.cluster_name>
     *
     * @generated from field: string external_cluster = 10;
     */
    externalCluster = '';

    /**
     * SourceTimeZone is the time zone in which datetimes on the source were stored, provided as an option in MoveTables
     *
     * @generated from field: string source_time_zone = 11;
     */
    sourceTimeZone = '';

    /**
     * TargetTimeZone is not currently specifiable by the user, defaults to UTC for the forward workflows
     * and to the SourceTimeZone in reverse workflows
     *
     * @generated from field: string target_time_zone = 12;
     */
    targetTimeZone = '';

    constructor(data?: PartialMessage<BinlogSource>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.BinlogSource';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'keyspace', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'shard', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 3, name: 'tablet_type', kind: 'enum', T: proto3.getEnumType(TabletType) },
        { no: 4, name: 'key_range', kind: 'message', T: KeyRange },
        { no: 5, name: 'tables', kind: 'scalar', T: 9 /* ScalarType.STRING */, repeated: true },
        { no: 6, name: 'filter', kind: 'message', T: Filter },
        { no: 7, name: 'on_ddl', kind: 'enum', T: proto3.getEnumType(OnDDLAction) },
        { no: 8, name: 'external_mysql', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 9, name: 'stop_after_copy', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        { no: 10, name: 'external_cluster', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 11, name: 'source_time_zone', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 12, name: 'target_time_zone', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BinlogSource {
        return new BinlogSource().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BinlogSource {
        return new BinlogSource().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BinlogSource {
        return new BinlogSource().fromJsonString(jsonString, options);
    }

    static equals(
        a: BinlogSource | PlainMessage<BinlogSource> | undefined,
        b: BinlogSource | PlainMessage<BinlogSource> | undefined,
    ): boolean {
        return proto3.util.equals(BinlogSource, a, b);
    }
}

/**
 * RowChange represents one row change.
 * If Before is set and not After, it's a delete.
 * If After is set and not Before, it's an insert.
 * If both are set, it's an update.
 *
 * @generated from message binlogdata.RowChange
 */
export class RowChange extends Message<RowChange> {
    /**
     * @generated from field: query.Row before = 1;
     */
    before?: Row;

    /**
     * @generated from field: query.Row after = 2;
     */
    after?: Row;

    /**
     * DataColumns is a bitmap of all columns: bit is set if column is present in the after image
     *
     * @generated from field: binlogdata.RowChange.Bitmap data_columns = 3;
     */
    dataColumns?: RowChange_Bitmap;

    constructor(data?: PartialMessage<RowChange>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.RowChange';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'before', kind: 'message', T: Row },
        { no: 2, name: 'after', kind: 'message', T: Row },
        { no: 3, name: 'data_columns', kind: 'message', T: RowChange_Bitmap },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RowChange {
        return new RowChange().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RowChange {
        return new RowChange().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RowChange {
        return new RowChange().fromJsonString(jsonString, options);
    }

    static equals(
        a: RowChange | PlainMessage<RowChange> | undefined,
        b: RowChange | PlainMessage<RowChange> | undefined,
    ): boolean {
        return proto3.util.equals(RowChange, a, b);
    }
}

/**
 * @generated from message binlogdata.RowChange.Bitmap
 */
export class RowChange_Bitmap extends Message<RowChange_Bitmap> {
    /**
     * @generated from field: int64 count = 1;
     */
    count = protoInt64.zero;

    /**
     * @generated from field: bytes cols = 2;
     */
    cols = new Uint8Array(0);

    constructor(data?: PartialMessage<RowChange_Bitmap>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.RowChange.Bitmap';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'count', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 2, name: 'cols', kind: 'scalar', T: 12 /* ScalarType.BYTES */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RowChange_Bitmap {
        return new RowChange_Bitmap().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RowChange_Bitmap {
        return new RowChange_Bitmap().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): RowChange_Bitmap {
        return new RowChange_Bitmap().fromJsonString(jsonString, options);
    }

    static equals(
        a: RowChange_Bitmap | PlainMessage<RowChange_Bitmap> | undefined,
        b: RowChange_Bitmap | PlainMessage<RowChange_Bitmap> | undefined,
    ): boolean {
        return proto3.util.equals(RowChange_Bitmap, a, b);
    }
}

/**
 * RowEvent represent row events for one table.
 *
 * @generated from message binlogdata.RowEvent
 */
export class RowEvent extends Message<RowEvent> {
    /**
     * @generated from field: string table_name = 1;
     */
    tableName = '';

    /**
     * @generated from field: repeated binlogdata.RowChange row_changes = 2;
     */
    rowChanges: RowChange[] = [];

    /**
     * @generated from field: string keyspace = 3;
     */
    keyspace = '';

    /**
     * @generated from field: string shard = 4;
     */
    shard = '';

    /**
     * https://dev.mysql.com/doc/dev/mysql-server/latest/classbinary__log_1_1Rows__event.html
     *
     * @generated from field: uint32 flags = 5;
     */
    flags = 0;

    /**
     * set for sidecardb tables
     *
     * @generated from field: bool is_internal_table = 6;
     */
    isInternalTable = false;

    constructor(data?: PartialMessage<RowEvent>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.RowEvent';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'table_name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'row_changes', kind: 'message', T: RowChange, repeated: true },
        { no: 3, name: 'keyspace', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 4, name: 'shard', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 5, name: 'flags', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
        { no: 6, name: 'is_internal_table', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RowEvent {
        return new RowEvent().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RowEvent {
        return new RowEvent().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RowEvent {
        return new RowEvent().fromJsonString(jsonString, options);
    }

    static equals(
        a: RowEvent | PlainMessage<RowEvent> | undefined,
        b: RowEvent | PlainMessage<RowEvent> | undefined,
    ): boolean {
        return proto3.util.equals(RowEvent, a, b);
    }
}

/**
 * FieldEvent represents the field info for a table.
 *
 * @generated from message binlogdata.FieldEvent
 */
export class FieldEvent extends Message<FieldEvent> {
    /**
     * @generated from field: string table_name = 1;
     */
    tableName = '';

    /**
     * @generated from field: repeated query.Field fields = 2;
     */
    fields: Field[] = [];

    /**
     * @generated from field: string keyspace = 3;
     */
    keyspace = '';

    /**
     * @generated from field: string shard = 4;
     */
    shard = '';

    /**
     * Are ENUM and SET field values already mapped to strings in the ROW
     * events? This allows us to transition VTGate VStream consumers from
     * the pre v20 behavior of having to do this mapping themselves to the
     * v20+ behavior of not having to do this anymore and to expect string
     * values directly.
     * NOTE: because this is the use case, this is ONLY ever set today in
     * vstreams managed by the vstreamManager.
     *
     * @generated from field: bool enum_set_string_values = 25;
     */
    enumSetStringValues = false;

    /**
     * set for sidecardb tables
     *
     * @generated from field: bool is_internal_table = 26;
     */
    isInternalTable = false;

    constructor(data?: PartialMessage<FieldEvent>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.FieldEvent';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'table_name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'fields', kind: 'message', T: Field, repeated: true },
        { no: 3, name: 'keyspace', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 4, name: 'shard', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 25, name: 'enum_set_string_values', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        { no: 26, name: 'is_internal_table', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldEvent {
        return new FieldEvent().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldEvent {
        return new FieldEvent().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldEvent {
        return new FieldEvent().fromJsonString(jsonString, options);
    }

    static equals(
        a: FieldEvent | PlainMessage<FieldEvent> | undefined,
        b: FieldEvent | PlainMessage<FieldEvent> | undefined,
    ): boolean {
        return proto3.util.equals(FieldEvent, a, b);
    }
}

/**
 * ShardGtid contains the GTID position for one shard.
 * It's used in a request for requesting a starting position.
 * It's used in a response to transmit the current position
 * of a shard. It's also used in a Journal to indicate the
 * list of targets and shard positions to migrate to.
 *
 * @generated from message binlogdata.ShardGtid
 */
export class ShardGtid extends Message<ShardGtid> {
    /**
     * @generated from field: string keyspace = 1;
     */
    keyspace = '';

    /**
     * @generated from field: string shard = 2;
     */
    shard = '';

    /**
     * @generated from field: string gtid = 3;
     */
    gtid = '';

    /**
     * @generated from field: repeated binlogdata.TableLastPK table_p_ks = 4;
     */
    tablePKs: TableLastPK[] = [];

    constructor(data?: PartialMessage<ShardGtid>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.ShardGtid';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'keyspace', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'shard', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 3, name: 'gtid', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 4, name: 'table_p_ks', kind: 'message', T: TableLastPK, repeated: true },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShardGtid {
        return new ShardGtid().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShardGtid {
        return new ShardGtid().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShardGtid {
        return new ShardGtid().fromJsonString(jsonString, options);
    }

    static equals(
        a: ShardGtid | PlainMessage<ShardGtid> | undefined,
        b: ShardGtid | PlainMessage<ShardGtid> | undefined,
    ): boolean {
        return proto3.util.equals(ShardGtid, a, b);
    }
}

/**
 * A VGtid is a list of ShardGtids.
 *
 * @generated from message binlogdata.VGtid
 */
export class VGtid extends Message<VGtid> {
    /**
     * @generated from field: repeated binlogdata.ShardGtid shard_gtids = 1;
     */
    shardGtids: ShardGtid[] = [];

    constructor(data?: PartialMessage<VGtid>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.VGtid';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'shard_gtids', kind: 'message', T: ShardGtid, repeated: true },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VGtid {
        return new VGtid().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VGtid {
        return new VGtid().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VGtid {
        return new VGtid().fromJsonString(jsonString, options);
    }

    static equals(
        a: VGtid | PlainMessage<VGtid> | undefined,
        b: VGtid | PlainMessage<VGtid> | undefined,
    ): boolean {
        return proto3.util.equals(VGtid, a, b);
    }
}

/**
 * KeyspaceShard represents a keyspace and shard.
 *
 * @generated from message binlogdata.KeyspaceShard
 */
export class KeyspaceShard extends Message<KeyspaceShard> {
    /**
     * @generated from field: string keyspace = 1;
     */
    keyspace = '';

    /**
     * @generated from field: string shard = 2;
     */
    shard = '';

    constructor(data?: PartialMessage<KeyspaceShard>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.KeyspaceShard';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'keyspace', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'shard', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeyspaceShard {
        return new KeyspaceShard().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeyspaceShard {
        return new KeyspaceShard().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeyspaceShard {
        return new KeyspaceShard().fromJsonString(jsonString, options);
    }

    static equals(
        a: KeyspaceShard | PlainMessage<KeyspaceShard> | undefined,
        b: KeyspaceShard | PlainMessage<KeyspaceShard> | undefined,
    ): boolean {
        return proto3.util.equals(KeyspaceShard, a, b);
    }
}

/**
 * Journal contains the metadata for a journal event.
 * The commit of a journal event indicates the point of no return
 * for a migration.
 *
 * @generated from message binlogdata.Journal
 */
export class Journal extends Message<Journal> {
    /**
     * Id represents a unique journal id.
     *
     * @generated from field: int64 id = 1;
     */
    id = protoInt64.zero;

    /**
     * @generated from field: binlogdata.MigrationType migration_type = 2;
     */
    migrationType = MigrationType.TABLES;

    /**
     * Tables is set if the journal represents a TABLES migration.
     *
     * @generated from field: repeated string tables = 3;
     */
    tables: string[] = [];

    /**
     * LocalPosition is the source position at which the migration happened.
     *
     * @generated from field: string local_position = 4;
     */
    localPosition = '';

    /**
     * ShardGtids is the list of targets to which the migration took place.
     *
     * @generated from field: repeated binlogdata.ShardGtid shard_gtids = 5;
     */
    shardGtids: ShardGtid[] = [];

    /**
     * Participants is the list of source participants for a migration.
     * Every participant is expected to have an identical journal entry.
     * While streaming, the client must wait for the journal entry to
     * be received from all pariticipants, and then replace them with new
     * streams specified by ShardGtid.
     * If a stream does not have all participants, a consistent migration
     * is not possible.
     *
     * @generated from field: repeated binlogdata.KeyspaceShard participants = 6;
     */
    participants: KeyspaceShard[] = [];

    /**
     * SourceWorkflows is the list of workflows in the source shard that
     * were migrated to the target. If a migration fails after a Journal
     * is committed, this information is used to start the target streams
     * that were created prior to the creation of the journal.
     *
     * @generated from field: repeated string source_workflows = 7;
     */
    sourceWorkflows: string[] = [];

    constructor(data?: PartialMessage<Journal>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.Journal';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 2, name: 'migration_type', kind: 'enum', T: proto3.getEnumType(MigrationType) },
        { no: 3, name: 'tables', kind: 'scalar', T: 9 /* ScalarType.STRING */, repeated: true },
        { no: 4, name: 'local_position', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 5, name: 'shard_gtids', kind: 'message', T: ShardGtid, repeated: true },
        { no: 6, name: 'participants', kind: 'message', T: KeyspaceShard, repeated: true },
        {
            no: 7,
            name: 'source_workflows',
            kind: 'scalar',
            T: 9 /* ScalarType.STRING */,
            repeated: true,
        },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Journal {
        return new Journal().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Journal {
        return new Journal().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Journal {
        return new Journal().fromJsonString(jsonString, options);
    }

    static equals(
        a: Journal | PlainMessage<Journal> | undefined,
        b: Journal | PlainMessage<Journal> | undefined,
    ): boolean {
        return proto3.util.equals(Journal, a, b);
    }
}

/**
 * VEvent represents a vstream event.
 * A FieldEvent is sent once for every table, just before
 * the first event for that table. The client is expected
 * to cache this information and match it against the RowEvent
 * which contains the table name.
 * A GTID event always precedes a commitable event, which can be
 * COMMIT, DDL or OTHER.
 * OTHER events are non-material events that have no additional metadata.
 *
 * @generated from message binlogdata.VEvent
 */
export class VEvent extends Message<VEvent> {
    /**
     * @generated from field: binlogdata.VEventType type = 1;
     */
    type = VEventType.UNKNOWN;

    /**
     * Timestamp is the binlog timestamp in seconds.
     * The value should be ignored if 0.
     *
     * @generated from field: int64 timestamp = 2;
     */
    timestamp = protoInt64.zero;

    /**
     * Gtid is set if the event type is GTID.
     *
     * @generated from field: string gtid = 3;
     */
    gtid = '';

    /**
     * Statement is set if the event type is DDL, DML or SAVEPOINT.
     *
     * @generated from field: string statement = 4;
     */
    statement = '';

    /**
     * RowEvent is set if the event type is ROW.
     *
     * @generated from field: binlogdata.RowEvent row_event = 5;
     */
    rowEvent?: RowEvent;

    /**
     * FieldEvent is set if the event type is FIELD.
     *
     * @generated from field: binlogdata.FieldEvent field_event = 6;
     */
    fieldEvent?: FieldEvent;

    /**
     * Vgtid is set if the event type is VGTID.
     * This event is only generated by VTGate's VStream function.
     *
     * @generated from field: binlogdata.VGtid vgtid = 7;
     */
    vgtid?: VGtid;

    /**
     * Journal is set if the event type is JOURNAL.
     *
     * @generated from field: binlogdata.Journal journal = 8;
     */
    journal?: Journal;

    /**
     * Dml is set if the event type is INSERT, REPLACE, UPDATE or DELETE.
     *
     * @generated from field: string dml = 9;
     */
    dml = '';

    /**
     * CurrentTime specifies the current time when the message was sent.
     * This can be used to compenssate for clock skew.
     *
     * @generated from field: int64 current_time = 20;
     */
    currentTime = protoInt64.zero;

    /**
     * LastPK is the last PK for a table
     *
     * @generated from field: binlogdata.LastPKEvent last_p_k_event = 21;
     */
    lastPKEvent?: LastPKEvent;

    /**
     * the source keyspace
     *
     * @generated from field: string keyspace = 22;
     */
    keyspace = '';

    /**
     * the source shard
     *
     * @generated from field: string shard = 23;
     */
    shard = '';

    /**
     * indicate that we are being throttled right now
     *
     * @generated from field: bool throttled = 24;
     */
    throttled = false;

    /**
     * ThrottledReason is a human readable string that explains why the stream is throttled
     *
     * @generated from field: string throttled_reason = 25;
     */
    throttledReason = '';

    constructor(data?: PartialMessage<VEvent>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.VEvent';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'type', kind: 'enum', T: proto3.getEnumType(VEventType) },
        { no: 2, name: 'timestamp', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 3, name: 'gtid', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 4, name: 'statement', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 5, name: 'row_event', kind: 'message', T: RowEvent },
        { no: 6, name: 'field_event', kind: 'message', T: FieldEvent },
        { no: 7, name: 'vgtid', kind: 'message', T: VGtid },
        { no: 8, name: 'journal', kind: 'message', T: Journal },
        { no: 9, name: 'dml', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 20, name: 'current_time', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 21, name: 'last_p_k_event', kind: 'message', T: LastPKEvent },
        { no: 22, name: 'keyspace', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 23, name: 'shard', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 24, name: 'throttled', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        { no: 25, name: 'throttled_reason', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VEvent {
        return new VEvent().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VEvent {
        return new VEvent().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VEvent {
        return new VEvent().fromJsonString(jsonString, options);
    }

    static equals(
        a: VEvent | PlainMessage<VEvent> | undefined,
        b: VEvent | PlainMessage<VEvent> | undefined,
    ): boolean {
        return proto3.util.equals(VEvent, a, b);
    }
}

/**
 * @generated from message binlogdata.MinimalTable
 */
export class MinimalTable extends Message<MinimalTable> {
    /**
     * @generated from field: string name = 1;
     */
    name = '';

    /**
     * @generated from field: repeated query.Field fields = 2;
     */
    fields: Field[] = [];

    /**
     * @generated from field: repeated int64 p_k_columns = 3;
     */
    pKColumns: bigint[] = [];

    /**
     * This will be PRIMARY when the actual primary key is used and it
     * will be the name of the Primary Key equivalent if one is used
     * instead. Otherwise it will be empty.
     *
     * @generated from field: string p_k_index_name = 4;
     */
    pKIndexName = '';

    constructor(data?: PartialMessage<MinimalTable>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.MinimalTable';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'fields', kind: 'message', T: Field, repeated: true },
        { no: 3, name: 'p_k_columns', kind: 'scalar', T: 3 /* ScalarType.INT64 */, repeated: true },
        { no: 4, name: 'p_k_index_name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MinimalTable {
        return new MinimalTable().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MinimalTable {
        return new MinimalTable().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MinimalTable {
        return new MinimalTable().fromJsonString(jsonString, options);
    }

    static equals(
        a: MinimalTable | PlainMessage<MinimalTable> | undefined,
        b: MinimalTable | PlainMessage<MinimalTable> | undefined,
    ): boolean {
        return proto3.util.equals(MinimalTable, a, b);
    }
}

/**
 * @generated from message binlogdata.MinimalSchema
 */
export class MinimalSchema extends Message<MinimalSchema> {
    /**
     * @generated from field: repeated binlogdata.MinimalTable tables = 1;
     */
    tables: MinimalTable[] = [];

    constructor(data?: PartialMessage<MinimalSchema>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.MinimalSchema';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'tables', kind: 'message', T: MinimalTable, repeated: true },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MinimalSchema {
        return new MinimalSchema().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MinimalSchema {
        return new MinimalSchema().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MinimalSchema {
        return new MinimalSchema().fromJsonString(jsonString, options);
    }

    static equals(
        a: MinimalSchema | PlainMessage<MinimalSchema> | undefined,
        b: MinimalSchema | PlainMessage<MinimalSchema> | undefined,
    ): boolean {
        return proto3.util.equals(MinimalSchema, a, b);
    }
}

/**
 * @generated from message binlogdata.VStreamOptions
 */
export class VStreamOptions extends Message<VStreamOptions> {
    /**
     * @generated from field: repeated string internal_tables = 1;
     */
    internalTables: string[] = [];

    /**
     * @generated from field: map<string, string> config_overrides = 2;
     */
    configOverrides: { [key: string]: string } = {};

    constructor(data?: PartialMessage<VStreamOptions>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.VStreamOptions';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        {
            no: 1,
            name: 'internal_tables',
            kind: 'scalar',
            T: 9 /* ScalarType.STRING */,
            repeated: true,
        },
        {
            no: 2,
            name: 'config_overrides',
            kind: 'map',
            K: 9 /* ScalarType.STRING */,
            V: { kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VStreamOptions {
        return new VStreamOptions().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VStreamOptions {
        return new VStreamOptions().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VStreamOptions {
        return new VStreamOptions().fromJsonString(jsonString, options);
    }

    static equals(
        a: VStreamOptions | PlainMessage<VStreamOptions> | undefined,
        b: VStreamOptions | PlainMessage<VStreamOptions> | undefined,
    ): boolean {
        return proto3.util.equals(VStreamOptions, a, b);
    }
}

/**
 * VStreamRequest is the payload for VStreamer
 *
 * @generated from message binlogdata.VStreamRequest
 */
export class VStreamRequest extends Message<VStreamRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: string position = 4;
     */
    position = '';

    /**
     * @generated from field: binlogdata.Filter filter = 5;
     */
    filter?: Filter;

    /**
     * @generated from field: repeated binlogdata.TableLastPK table_last_p_ks = 6;
     */
    tableLastPKs: TableLastPK[] = [];

    /**
     * @generated from field: binlogdata.VStreamOptions options = 7;
     */
    options?: VStreamOptions;

    constructor(data?: PartialMessage<VStreamRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.VStreamRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'position', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 5, name: 'filter', kind: 'message', T: Filter },
        { no: 6, name: 'table_last_p_ks', kind: 'message', T: TableLastPK, repeated: true },
        { no: 7, name: 'options', kind: 'message', T: VStreamOptions },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VStreamRequest {
        return new VStreamRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VStreamRequest {
        return new VStreamRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VStreamRequest {
        return new VStreamRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: VStreamRequest | PlainMessage<VStreamRequest> | undefined,
        b: VStreamRequest | PlainMessage<VStreamRequest> | undefined,
    ): boolean {
        return proto3.util.equals(VStreamRequest, a, b);
    }
}

/**
 * VStreamResponse is the response from VStreamer
 *
 * @generated from message binlogdata.VStreamResponse
 */
export class VStreamResponse extends Message<VStreamResponse> {
    /**
     * @generated from field: repeated binlogdata.VEvent events = 1;
     */
    events: VEvent[] = [];

    constructor(data?: PartialMessage<VStreamResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.VStreamResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'events', kind: 'message', T: VEvent, repeated: true },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VStreamResponse {
        return new VStreamResponse().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VStreamResponse {
        return new VStreamResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VStreamResponse {
        return new VStreamResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: VStreamResponse | PlainMessage<VStreamResponse> | undefined,
        b: VStreamResponse | PlainMessage<VStreamResponse> | undefined,
    ): boolean {
        return proto3.util.equals(VStreamResponse, a, b);
    }
}

/**
 * VStreamRowsRequest is the payload for VStreamRows
 *
 * @generated from message binlogdata.VStreamRowsRequest
 */
export class VStreamRowsRequest extends Message<VStreamRowsRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: string query = 4;
     */
    query = '';

    /**
     * @generated from field: query.QueryResult lastpk = 5;
     */
    lastpk?: QueryResult;

    /**
     * @generated from field: binlogdata.VStreamOptions options = 6;
     */
    options?: VStreamOptions;

    constructor(data?: PartialMessage<VStreamRowsRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.VStreamRowsRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'query', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 5, name: 'lastpk', kind: 'message', T: QueryResult },
        { no: 6, name: 'options', kind: 'message', T: VStreamOptions },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VStreamRowsRequest {
        return new VStreamRowsRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VStreamRowsRequest {
        return new VStreamRowsRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): VStreamRowsRequest {
        return new VStreamRowsRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: VStreamRowsRequest | PlainMessage<VStreamRowsRequest> | undefined,
        b: VStreamRowsRequest | PlainMessage<VStreamRowsRequest> | undefined,
    ): boolean {
        return proto3.util.equals(VStreamRowsRequest, a, b);
    }
}

/**
 * VStreamRowsResponse is the response from VStreamRows
 *
 * @generated from message binlogdata.VStreamRowsResponse
 */
export class VStreamRowsResponse extends Message<VStreamRowsResponse> {
    /**
     * @generated from field: repeated query.Field fields = 1;
     */
    fields: Field[] = [];

    /**
     * @generated from field: repeated query.Field pkfields = 2;
     */
    pkfields: Field[] = [];

    /**
     * @generated from field: string gtid = 3;
     */
    gtid = '';

    /**
     * @generated from field: repeated query.Row rows = 4;
     */
    rows: Row[] = [];

    /**
     * @generated from field: query.Row lastpk = 5;
     */
    lastpk?: Row;

    /**
     * Throttled indicates that rowstreamer is being throttled right now
     *
     * @generated from field: bool throttled = 6;
     */
    throttled = false;

    /**
     * Heartbeat indicates that this is a heartbeat message
     *
     * @generated from field: bool heartbeat = 7;
     */
    heartbeat = false;

    /**
     * ThrottledReason is a human readable string that explains why the stream is throttled
     *
     * @generated from field: string throttled_reason = 8;
     */
    throttledReason = '';

    constructor(data?: PartialMessage<VStreamRowsResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.VStreamRowsResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'fields', kind: 'message', T: Field, repeated: true },
        { no: 2, name: 'pkfields', kind: 'message', T: Field, repeated: true },
        { no: 3, name: 'gtid', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 4, name: 'rows', kind: 'message', T: Row, repeated: true },
        { no: 5, name: 'lastpk', kind: 'message', T: Row },
        { no: 6, name: 'throttled', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        { no: 7, name: 'heartbeat', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        { no: 8, name: 'throttled_reason', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): VStreamRowsResponse {
        return new VStreamRowsResponse().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VStreamRowsResponse {
        return new VStreamRowsResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): VStreamRowsResponse {
        return new VStreamRowsResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: VStreamRowsResponse | PlainMessage<VStreamRowsResponse> | undefined,
        b: VStreamRowsResponse | PlainMessage<VStreamRowsResponse> | undefined,
    ): boolean {
        return proto3.util.equals(VStreamRowsResponse, a, b);
    }
}

/**
 * VStreamTablesRequest is the payload for VStreamTables
 *
 * @generated from message binlogdata.VStreamTablesRequest
 */
export class VStreamTablesRequest extends Message<VStreamTablesRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: binlogdata.VStreamOptions options = 4;
     */
    options?: VStreamOptions;

    constructor(data?: PartialMessage<VStreamTablesRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.VStreamTablesRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'options', kind: 'message', T: VStreamOptions },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): VStreamTablesRequest {
        return new VStreamTablesRequest().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): VStreamTablesRequest {
        return new VStreamTablesRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): VStreamTablesRequest {
        return new VStreamTablesRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: VStreamTablesRequest | PlainMessage<VStreamTablesRequest> | undefined,
        b: VStreamTablesRequest | PlainMessage<VStreamTablesRequest> | undefined,
    ): boolean {
        return proto3.util.equals(VStreamTablesRequest, a, b);
    }
}

/**
 * VStreamTablesResponse is the response from VStreamTables
 *
 * @generated from message binlogdata.VStreamTablesResponse
 */
export class VStreamTablesResponse extends Message<VStreamTablesResponse> {
    /**
     * @generated from field: string table_name = 1;
     */
    tableName = '';

    /**
     * @generated from field: repeated query.Field fields = 2;
     */
    fields: Field[] = [];

    /**
     * @generated from field: repeated query.Field pkfields = 3;
     */
    pkfields: Field[] = [];

    /**
     * @generated from field: string gtid = 4;
     */
    gtid = '';

    /**
     * @generated from field: repeated query.Row rows = 5;
     */
    rows: Row[] = [];

    /**
     * @generated from field: query.Row lastpk = 6;
     */
    lastpk?: Row;

    constructor(data?: PartialMessage<VStreamTablesResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.VStreamTablesResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'table_name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'fields', kind: 'message', T: Field, repeated: true },
        { no: 3, name: 'pkfields', kind: 'message', T: Field, repeated: true },
        { no: 4, name: 'gtid', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 5, name: 'rows', kind: 'message', T: Row, repeated: true },
        { no: 6, name: 'lastpk', kind: 'message', T: Row },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): VStreamTablesResponse {
        return new VStreamTablesResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): VStreamTablesResponse {
        return new VStreamTablesResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): VStreamTablesResponse {
        return new VStreamTablesResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: VStreamTablesResponse | PlainMessage<VStreamTablesResponse> | undefined,
        b: VStreamTablesResponse | PlainMessage<VStreamTablesResponse> | undefined,
    ): boolean {
        return proto3.util.equals(VStreamTablesResponse, a, b);
    }
}

/**
 * @generated from message binlogdata.LastPKEvent
 */
export class LastPKEvent extends Message<LastPKEvent> {
    /**
     * @generated from field: binlogdata.TableLastPK table_last_p_k = 1;
     */
    tableLastPK?: TableLastPK;

    /**
     * @generated from field: bool completed = 2;
     */
    completed = false;

    constructor(data?: PartialMessage<LastPKEvent>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.LastPKEvent';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'table_last_p_k', kind: 'message', T: TableLastPK },
        { no: 2, name: 'completed', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LastPKEvent {
        return new LastPKEvent().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LastPKEvent {
        return new LastPKEvent().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LastPKEvent {
        return new LastPKEvent().fromJsonString(jsonString, options);
    }

    static equals(
        a: LastPKEvent | PlainMessage<LastPKEvent> | undefined,
        b: LastPKEvent | PlainMessage<LastPKEvent> | undefined,
    ): boolean {
        return proto3.util.equals(LastPKEvent, a, b);
    }
}

/**
 * @generated from message binlogdata.TableLastPK
 */
export class TableLastPK extends Message<TableLastPK> {
    /**
     * @generated from field: string table_name = 1;
     */
    tableName = '';

    /**
     * @generated from field: query.QueryResult lastpk = 3;
     */
    lastpk?: QueryResult;

    constructor(data?: PartialMessage<TableLastPK>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.TableLastPK';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'table_name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 3, name: 'lastpk', kind: 'message', T: QueryResult },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TableLastPK {
        return new TableLastPK().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TableLastPK {
        return new TableLastPK().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TableLastPK {
        return new TableLastPK().fromJsonString(jsonString, options);
    }

    static equals(
        a: TableLastPK | PlainMessage<TableLastPK> | undefined,
        b: TableLastPK | PlainMessage<TableLastPK> | undefined,
    ): boolean {
        return proto3.util.equals(TableLastPK, a, b);
    }
}

/**
 * VStreamResultsRequest is the payload for VStreamResults
 * The ids match VStreamRows, in case we decide to merge the two.
 * The ids match VStreamRows, in case we decide to merge the two.
 *
 * @generated from message binlogdata.VStreamResultsRequest
 */
export class VStreamResultsRequest extends Message<VStreamResultsRequest> {
    /**
     * @generated from field: vtrpc.CallerID effective_caller_id = 1;
     */
    effectiveCallerId?: CallerID;

    /**
     * @generated from field: query.VTGateCallerID immediate_caller_id = 2;
     */
    immediateCallerId?: VTGateCallerID;

    /**
     * @generated from field: query.Target target = 3;
     */
    target?: Target;

    /**
     * @generated from field: string query = 4;
     */
    query = '';

    constructor(data?: PartialMessage<VStreamResultsRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.VStreamResultsRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'effective_caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'immediate_caller_id', kind: 'message', T: VTGateCallerID },
        { no: 3, name: 'target', kind: 'message', T: Target },
        { no: 4, name: 'query', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): VStreamResultsRequest {
        return new VStreamResultsRequest().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): VStreamResultsRequest {
        return new VStreamResultsRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): VStreamResultsRequest {
        return new VStreamResultsRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: VStreamResultsRequest | PlainMessage<VStreamResultsRequest> | undefined,
        b: VStreamResultsRequest | PlainMessage<VStreamResultsRequest> | undefined,
    ): boolean {
        return proto3.util.equals(VStreamResultsRequest, a, b);
    }
}

/**
 * VStreamResultsResponse is the response from VStreamResults
 * The ids match VStreamRows, in case we decide to merge the two.
 *
 * @generated from message binlogdata.VStreamResultsResponse
 */
export class VStreamResultsResponse extends Message<VStreamResultsResponse> {
    /**
     * @generated from field: repeated query.Field fields = 1;
     */
    fields: Field[] = [];

    /**
     * @generated from field: string gtid = 3;
     */
    gtid = '';

    /**
     * @generated from field: repeated query.Row rows = 4;
     */
    rows: Row[] = [];

    constructor(data?: PartialMessage<VStreamResultsResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'binlogdata.VStreamResultsResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'fields', kind: 'message', T: Field, repeated: true },
        { no: 3, name: 'gtid', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 4, name: 'rows', kind: 'message', T: Row, repeated: true },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): VStreamResultsResponse {
        return new VStreamResultsResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): VStreamResultsResponse {
        return new VStreamResultsResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): VStreamResultsResponse {
        return new VStreamResultsResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: VStreamResultsResponse | PlainMessage<VStreamResultsResponse> | undefined,
        b: VStreamResultsResponse | PlainMessage<VStreamResultsResponse> | undefined,
    ): boolean {
        return proto3.util.equals(VStreamResultsResponse, a, b);
    }
}
