//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file contains the Vitess topology related data structures.
// Very few of these structures are exchanged over the wire (only
// TabletType and KeyRange), but they are all used by the topology
// service.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file topodata.proto (package topodata, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import {
    Message,
    proto3,
    type BinaryReadOptions,
    type FieldList,
    type JsonReadOptions,
    type JsonValue,
    type PartialMessage,
    type PlainMessage,
} from '@bufbuild/protobuf';
import { Time } from './vttime_pb.js';

/**
 * KeyspaceType describes the type of the keyspace
 *
 * @generated from enum topodata.KeyspaceType
 */
export enum KeyspaceType {
    /**
     * NORMAL is the default value
     *
     * @generated from enum value: NORMAL = 0;
     */
    NORMAL = 0,

    /**
     * SNAPSHOT is when we are creating a snapshot keyspace
     *
     * @generated from enum value: SNAPSHOT = 1;
     */
    SNAPSHOT = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(KeyspaceType)
proto3.util.setEnumType(KeyspaceType, 'topodata.KeyspaceType', [
    { no: 0, name: 'NORMAL' },
    { no: 1, name: 'SNAPSHOT' },
]);

/**
 * TabletType represents the type of a given tablet.
 *
 * @generated from enum topodata.TabletType
 */
export enum TabletType {
    /**
     * UNKNOWN is not a valid value.
     *
     * @generated from enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,

    /**
     * PRIMARY is the primary server for the shard. Only PRIMARY allows DMLs.
     *
     * @generated from enum value: PRIMARY = 1;
     */
    PRIMARY = 1,

    /**
     * DEPRECATED
     *
     * @generated from enum value: MASTER = 1;
     */
    MASTER = 1,

    /**
     * REPLICA replicates from primary. It is used to serve live traffic.
     * A REPLICA can be promoted to PRIMARY. A demoted PRIMARY will go to REPLICA.
     *
     * @generated from enum value: REPLICA = 2;
     */
    REPLICA = 2,

    /**
     * RDONLY (old name) / BATCH (new name) is used to serve traffic for
     * long-running jobs. It is a separate type from REPLICA so
     * long-running queries don't affect web-like traffic.
     *
     * @generated from enum value: RDONLY = 3;
     */
    RDONLY = 3,

    /**
     * @generated from enum value: BATCH = 3;
     */
    BATCH = 3,

    /**
     * SPARE is a type of servers that cannot serve queries, but is available
     * in case an extra server is needed.
     *
     * @generated from enum value: SPARE = 4;
     */
    SPARE = 4,

    /**
     * EXPERIMENTAL is like SPARE, except it can serve queries. This
     * type can be used for usages not planned by Vitess, like online
     * export to another storage engine.
     *
     * @generated from enum value: EXPERIMENTAL = 5;
     */
    EXPERIMENTAL = 5,

    /**
     * BACKUP is the type a server goes to when taking a backup. No queries
     * can be served in BACKUP mode.
     *
     * @generated from enum value: BACKUP = 6;
     */
    BACKUP = 6,

    /**
     * RESTORE is the type a server uses when restoring a backup, at
     * startup time.  No queries can be served in RESTORE mode.
     *
     * @generated from enum value: RESTORE = 7;
     */
    RESTORE = 7,

    /**
     * DRAINED is the type a server goes into when used by Vitess tools
     * to perform an offline action. It is a serving type (as
     * the tools processes may need to run queries), but it's not used
     * to route queries from Vitess users. In this state,
     * this tablet is dedicated to the process that uses it.
     *
     * @generated from enum value: DRAINED = 8;
     */
    DRAINED = 8,
}
// Retrieve enum metadata with: proto3.getEnumType(TabletType)
proto3.util.setEnumType(TabletType, 'topodata.TabletType', [
    { no: 0, name: 'UNKNOWN' },
    { no: 1, name: 'PRIMARY' },
    { no: 1, name: 'MASTER' },
    { no: 2, name: 'REPLICA' },
    { no: 3, name: 'RDONLY' },
    { no: 3, name: 'BATCH' },
    { no: 4, name: 'SPARE' },
    { no: 5, name: 'EXPERIMENTAL' },
    { no: 6, name: 'BACKUP' },
    { no: 7, name: 'RESTORE' },
    { no: 8, name: 'DRAINED' },
]);

/**
 * KeyRange describes a range of sharding keys, when range-based
 * sharding is used.
 *
 * @generated from message topodata.KeyRange
 */
export class KeyRange extends Message<KeyRange> {
    /**
     * @generated from field: bytes start = 1;
     */
    start = new Uint8Array(0);

    /**
     * @generated from field: bytes end = 2;
     */
    end = new Uint8Array(0);

    constructor(data?: PartialMessage<KeyRange>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.KeyRange';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'start', kind: 'scalar', T: 12 /* ScalarType.BYTES */ },
        { no: 2, name: 'end', kind: 'scalar', T: 12 /* ScalarType.BYTES */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeyRange {
        return new KeyRange().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeyRange {
        return new KeyRange().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeyRange {
        return new KeyRange().fromJsonString(jsonString, options);
    }

    static equals(
        a: KeyRange | PlainMessage<KeyRange> | undefined,
        b: KeyRange | PlainMessage<KeyRange> | undefined,
    ): boolean {
        return proto3.util.equals(KeyRange, a, b);
    }
}

/**
 * TabletAlias is a globally unique tablet identifier.
 *
 * @generated from message topodata.TabletAlias
 */
export class TabletAlias extends Message<TabletAlias> {
    /**
     * cell is the cell (or datacenter) the tablet is in
     *
     * @generated from field: string cell = 1;
     */
    cell = '';

    /**
     * uid is a unique id for this tablet within the shard
     * (this is the MySQL server id as well).
     *
     * @generated from field: uint32 uid = 2;
     */
    uid = 0;

    constructor(data?: PartialMessage<TabletAlias>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.TabletAlias';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'cell', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'uid', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TabletAlias {
        return new TabletAlias().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TabletAlias {
        return new TabletAlias().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TabletAlias {
        return new TabletAlias().fromJsonString(jsonString, options);
    }

    static equals(
        a: TabletAlias | PlainMessage<TabletAlias> | undefined,
        b: TabletAlias | PlainMessage<TabletAlias> | undefined,
    ): boolean {
        return proto3.util.equals(TabletAlias, a, b);
    }
}

/**
 * Tablet represents information about a running instance of vttablet.
 *
 * @generated from message topodata.Tablet
 */
export class Tablet extends Message<Tablet> {
    /**
     * alias is the unique name of the tablet.
     *
     * @generated from field: topodata.TabletAlias alias = 1;
     */
    alias?: TabletAlias;

    /**
     * Fully qualified domain name of the host.
     *
     * @generated from field: string hostname = 2;
     */
    hostname = '';

    /**
     * Map of named ports. Normally this should include vt and grpc.
     * Going forward, the mysql port will be stored in mysql_port
     * instead of here.
     * For accessing mysql port, use topoproto.MysqlPort to fetch, and
     * topoproto.SetMysqlPort to set. These wrappers will ensure
     * legacy behavior is supported.
     *
     * @generated from field: map<string, int32> port_map = 4;
     */
    portMap: { [key: string]: number } = {};

    /**
     * Keyspace name.
     *
     * @generated from field: string keyspace = 5;
     */
    keyspace = '';

    /**
     * Shard name. If range based sharding is used, it should match
     * key_range.
     *
     * @generated from field: string shard = 6;
     */
    shard = '';

    /**
     * If range based sharding is used, range for the tablet's shard.
     *
     * @generated from field: topodata.KeyRange key_range = 7;
     */
    keyRange?: KeyRange;

    /**
     * type is the current type of the tablet.
     *
     * @generated from field: topodata.TabletType type = 8;
     */
    type = TabletType.UNKNOWN;

    /**
     * It this is set, it is used as the database name instead of the
     * normal "vt_" + keyspace.
     *
     * @generated from field: string db_name_override = 9;
     */
    dbNameOverride = '';

    /**
     * tablet tags
     *
     * @generated from field: map<string, string> tags = 10;
     */
    tags: { [key: string]: string } = {};

    /**
     * MySQL hostname.
     *
     * @generated from field: string mysql_hostname = 12;
     */
    mysqlHostname = '';

    /**
     * MySQL port. Use topoproto.MysqlPort and topoproto.SetMysqlPort
     * to access this variable. The functions provide support
     * for legacy behavior.
     *
     * @generated from field: int32 mysql_port = 13;
     */
    mysqlPort = 0;

    /**
     * primary_term_start_time is the time (in UTC) at which the current term of
     * the current tablet began as primary. If this tablet is not currently the
     * primary, this value is ignored.
     *
     * A new primary term begins any time an authoritative decision is communicated
     * about which tablet should be the primary, such as via Vitess
     * replication-management commands like PlannedReparentShard,
     * EmergencyReparentShard, and TabletExternallyReparented.
     *
     *
     * @generated from field: vttime.Time primary_term_start_time = 14;
     */
    primaryTermStartTime?: Time;

    /**
     * default_conn_collation is the default connection collation used by this tablet.
     *
     * @generated from field: uint32 default_conn_collation = 16;
     */
    defaultConnCollation = 0;

    constructor(data?: PartialMessage<Tablet>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.Tablet';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'alias', kind: 'message', T: TabletAlias },
        { no: 2, name: 'hostname', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        {
            no: 4,
            name: 'port_map',
            kind: 'map',
            K: 9 /* ScalarType.STRING */,
            V: { kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
        },
        { no: 5, name: 'keyspace', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 6, name: 'shard', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 7, name: 'key_range', kind: 'message', T: KeyRange },
        { no: 8, name: 'type', kind: 'enum', T: proto3.getEnumType(TabletType) },
        { no: 9, name: 'db_name_override', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        {
            no: 10,
            name: 'tags',
            kind: 'map',
            K: 9 /* ScalarType.STRING */,
            V: { kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        },
        { no: 12, name: 'mysql_hostname', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 13, name: 'mysql_port', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
        { no: 14, name: 'primary_term_start_time', kind: 'message', T: Time },
        { no: 16, name: 'default_conn_collation', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Tablet {
        return new Tablet().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Tablet {
        return new Tablet().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Tablet {
        return new Tablet().fromJsonString(jsonString, options);
    }

    static equals(
        a: Tablet | PlainMessage<Tablet> | undefined,
        b: Tablet | PlainMessage<Tablet> | undefined,
    ): boolean {
        return proto3.util.equals(Tablet, a, b);
    }
}

/**
 * A Shard contains data about a subset of the data whithin a keyspace.
 *
 * @generated from message topodata.Shard
 */
export class Shard extends Message<Shard> {
    /**
     * primary_alias is the tablet alias of the primary for the shard.
     * If it is unset, then there is no primary in this shard yet.
     * No lock is necessary to update this field, when for instance
     * TabletExternallyReparented updates this. However, we lock the
     * shard for reparenting operations (InitShardPrimary,
     * PlannedReparentShard,EmergencyReparentShard), to guarantee
     * exclusive operation.
     *
     * @generated from field: topodata.TabletAlias primary_alias = 1;
     */
    primaryAlias?: TabletAlias;

    /**
     * primary_term_start_time is the time (in UTC) at which the current term of
     * the primary specified in primary_alias began.
     *
     * A new primary term begins any time an authoritative decision is communicated
     * about which tablet should be the primary, such as via Vitess
     * replication-management commands like PlannedReparentShard,
     * EmergencyReparentShard, and TabletExternallyReparented.
     *
     * The primary_alias should only ever be changed if the new primary's term began
     * at a later time than this. Note that a new term can start for the tablet
     * that is already the primary. In that case, the primary_term_start_time would
     * be increased without changing the primary_alias.
     *
     * @generated from field: vttime.Time primary_term_start_time = 8;
     */
    primaryTermStartTime?: Time;

    /**
     * key_range is the KeyRange for this shard. It can be unset if:
     * - we are not using range-based sharding in this shard.
     * - the shard covers the entire keyrange.
     * This must match the shard name based on our other conventions, but
     * helpful to have it decomposed here.
     * Once set at creation time, it is never changed.
     *
     * @generated from field: topodata.KeyRange key_range = 2;
     */
    keyRange?: KeyRange;

    /**
     * SourceShards is the list of shards we're replicating from,
     * using filtered replication.
     * The keyspace lock is always taken when changing this.
     *
     * @generated from field: repeated topodata.Shard.SourceShard source_shards = 4;
     */
    sourceShards: Shard_SourceShard[] = [];

    /**
     * tablet_controls has at most one entry per TabletType.
     * The keyspace lock is always taken when changing this.
     *
     * @generated from field: repeated topodata.Shard.TabletControl tablet_controls = 6;
     */
    tabletControls: Shard_TabletControl[] = [];

    /**
     * is_primary_serving sets whether this shard primary is serving traffic or not.
     * The keyspace lock is always taken when changing this.
     *
     * @generated from field: bool is_primary_serving = 7;
     */
    isPrimaryServing = false;

    constructor(data?: PartialMessage<Shard>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.Shard';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'primary_alias', kind: 'message', T: TabletAlias },
        { no: 8, name: 'primary_term_start_time', kind: 'message', T: Time },
        { no: 2, name: 'key_range', kind: 'message', T: KeyRange },
        { no: 4, name: 'source_shards', kind: 'message', T: Shard_SourceShard, repeated: true },
        { no: 6, name: 'tablet_controls', kind: 'message', T: Shard_TabletControl, repeated: true },
        { no: 7, name: 'is_primary_serving', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Shard {
        return new Shard().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Shard {
        return new Shard().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Shard {
        return new Shard().fromJsonString(jsonString, options);
    }

    static equals(
        a: Shard | PlainMessage<Shard> | undefined,
        b: Shard | PlainMessage<Shard> | undefined,
    ): boolean {
        return proto3.util.equals(Shard, a, b);
    }
}

/**
 * SourceShard represents a data source for filtered replication
 * across shards. When this is used in a destination shard, the primary
 * of that shard will run filtered replication.
 *
 * @generated from message topodata.Shard.SourceShard
 */
export class Shard_SourceShard extends Message<Shard_SourceShard> {
    /**
     * Uid is the unique ID for this SourceShard object.
     *
     * @generated from field: int32 uid = 1;
     */
    uid = 0;

    /**
     * the source keyspace
     *
     * @generated from field: string keyspace = 2;
     */
    keyspace = '';

    /**
     * the source shard
     *
     * @generated from field: string shard = 3;
     */
    shard = '';

    /**
     * the source shard keyrange
     *
     * @generated from field: topodata.KeyRange key_range = 4;
     */
    keyRange?: KeyRange;

    /**
     * the source table list to replicate
     *
     * @generated from field: repeated string tables = 5;
     */
    tables: string[] = [];

    constructor(data?: PartialMessage<Shard_SourceShard>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.Shard.SourceShard';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'uid', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
        { no: 2, name: 'keyspace', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 3, name: 'shard', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 4, name: 'key_range', kind: 'message', T: KeyRange },
        { no: 5, name: 'tables', kind: 'scalar', T: 9 /* ScalarType.STRING */, repeated: true },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Shard_SourceShard {
        return new Shard_SourceShard().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Shard_SourceShard {
        return new Shard_SourceShard().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): Shard_SourceShard {
        return new Shard_SourceShard().fromJsonString(jsonString, options);
    }

    static equals(
        a: Shard_SourceShard | PlainMessage<Shard_SourceShard> | undefined,
        b: Shard_SourceShard | PlainMessage<Shard_SourceShard> | undefined,
    ): boolean {
        return proto3.util.equals(Shard_SourceShard, a, b);
    }
}

/**
 * TabletControl controls tablet's behavior
 *
 * @generated from message topodata.Shard.TabletControl
 */
export class Shard_TabletControl extends Message<Shard_TabletControl> {
    /**
     * which tablet type is affected
     *
     * @generated from field: topodata.TabletType tablet_type = 1;
     */
    tabletType = TabletType.UNKNOWN;

    /**
     * @generated from field: repeated string cells = 2;
     */
    cells: string[] = [];

    /**
     * @generated from field: repeated string denied_tables = 4;
     */
    deniedTables: string[] = [];

    /**
     * frozen is set if we've started failing over traffic for
     * the primary. If set, this record should not be removed.
     *
     * @generated from field: bool frozen = 5;
     */
    frozen = false;

    constructor(data?: PartialMessage<Shard_TabletControl>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.Shard.TabletControl';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'tablet_type', kind: 'enum', T: proto3.getEnumType(TabletType) },
        { no: 2, name: 'cells', kind: 'scalar', T: 9 /* ScalarType.STRING */, repeated: true },
        {
            no: 4,
            name: 'denied_tables',
            kind: 'scalar',
            T: 9 /* ScalarType.STRING */,
            repeated: true,
        },
        { no: 5, name: 'frozen', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): Shard_TabletControl {
        return new Shard_TabletControl().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Shard_TabletControl {
        return new Shard_TabletControl().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): Shard_TabletControl {
        return new Shard_TabletControl().fromJsonString(jsonString, options);
    }

    static equals(
        a: Shard_TabletControl | PlainMessage<Shard_TabletControl> | undefined,
        b: Shard_TabletControl | PlainMessage<Shard_TabletControl> | undefined,
    ): boolean {
        return proto3.util.equals(Shard_TabletControl, a, b);
    }
}

/**
 * A Keyspace contains data about a keyspace.
 *
 * @generated from message topodata.Keyspace
 */
export class Keyspace extends Message<Keyspace> {
    /**
     * keyspace_type will determine how this keyspace is treated by
     * vtgate / vschema. Normal keyspaces are routable by
     * any query. Snapshot keyspaces are only accessible
     * by explicit addresssing or by calling "use keyspace" first
     *
     * @generated from field: topodata.KeyspaceType keyspace_type = 5;
     */
    keyspaceType = KeyspaceType.NORMAL;

    /**
     * base_keyspace is the base keyspace from which a snapshot
     * keyspace is created. empty for normal keyspaces
     *
     * @generated from field: string base_keyspace = 6;
     */
    baseKeyspace = '';

    /**
     * snapshot_time (in UTC) is a property of snapshot
     * keyspaces which tells us what point in time
     * the snapshot is of
     *
     * @generated from field: vttime.Time snapshot_time = 7;
     */
    snapshotTime?: Time;

    /**
     * DurabilityPolicy is the durability policy to be
     * used for the keyspace.
     *
     * @generated from field: string durability_policy = 8;
     */
    durabilityPolicy = '';

    /**
     * ThrottlerConfig has the configuration for the tablet
     * server's lag throttler, and applies to the entire
     * keyspace, across all shards and tablets.
     *
     * @generated from field: topodata.ThrottlerConfig throttler_config = 9;
     */
    throttlerConfig?: ThrottlerConfig;

    /**
     * SidecarDBName is the name of the Vitess sidecar database
     * used for various system metadata that is stored in each
     * tablet's mysqld instance.
     *
     * @generated from field: string sidecar_db_name = 10;
     */
    sidecarDbName = '';

    constructor(data?: PartialMessage<Keyspace>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.Keyspace';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 5, name: 'keyspace_type', kind: 'enum', T: proto3.getEnumType(KeyspaceType) },
        { no: 6, name: 'base_keyspace', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 7, name: 'snapshot_time', kind: 'message', T: Time },
        { no: 8, name: 'durability_policy', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 9, name: 'throttler_config', kind: 'message', T: ThrottlerConfig },
        { no: 10, name: 'sidecar_db_name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Keyspace {
        return new Keyspace().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Keyspace {
        return new Keyspace().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Keyspace {
        return new Keyspace().fromJsonString(jsonString, options);
    }

    static equals(
        a: Keyspace | PlainMessage<Keyspace> | undefined,
        b: Keyspace | PlainMessage<Keyspace> | undefined,
    ): boolean {
        return proto3.util.equals(Keyspace, a, b);
    }
}

/**
 * ShardReplication describes the MySQL replication relationships
 * whithin a cell.
 *
 * @generated from message topodata.ShardReplication
 */
export class ShardReplication extends Message<ShardReplication> {
    /**
     * Note there can be only one Node in this array
     * for a given tablet.
     *
     * @generated from field: repeated topodata.ShardReplication.Node nodes = 1;
     */
    nodes: ShardReplication_Node[] = [];

    constructor(data?: PartialMessage<ShardReplication>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.ShardReplication';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'nodes', kind: 'message', T: ShardReplication_Node, repeated: true },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShardReplication {
        return new ShardReplication().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShardReplication {
        return new ShardReplication().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ShardReplication {
        return new ShardReplication().fromJsonString(jsonString, options);
    }

    static equals(
        a: ShardReplication | PlainMessage<ShardReplication> | undefined,
        b: ShardReplication | PlainMessage<ShardReplication> | undefined,
    ): boolean {
        return proto3.util.equals(ShardReplication, a, b);
    }
}

/**
 * Node describes a tablet instance within the cell
 *
 * @generated from message topodata.ShardReplication.Node
 */
export class ShardReplication_Node extends Message<ShardReplication_Node> {
    /**
     * @generated from field: topodata.TabletAlias tablet_alias = 1;
     */
    tabletAlias?: TabletAlias;

    constructor(data?: PartialMessage<ShardReplication_Node>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.ShardReplication.Node';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'tablet_alias', kind: 'message', T: TabletAlias },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ShardReplication_Node {
        return new ShardReplication_Node().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ShardReplication_Node {
        return new ShardReplication_Node().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ShardReplication_Node {
        return new ShardReplication_Node().fromJsonString(jsonString, options);
    }

    static equals(
        a: ShardReplication_Node | PlainMessage<ShardReplication_Node> | undefined,
        b: ShardReplication_Node | PlainMessage<ShardReplication_Node> | undefined,
    ): boolean {
        return proto3.util.equals(ShardReplication_Node, a, b);
    }
}

/**
 * ShardReplicationError describes the error being fixed by
 * ShardReplicationFix.
 *
 * @generated from message topodata.ShardReplicationError
 */
export class ShardReplicationError extends Message<ShardReplicationError> {
    /**
     * Type is the category of problem being fixed.
     *
     * @generated from field: topodata.ShardReplicationError.Type type = 1;
     */
    type = ShardReplicationError_Type.UNKNOWN;

    /**
     * TabletAlias is the tablet record that has the problem.
     *
     * @generated from field: topodata.TabletAlias tablet_alias = 2;
     */
    tabletAlias?: TabletAlias;

    constructor(data?: PartialMessage<ShardReplicationError>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.ShardReplicationError';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'type', kind: 'enum', T: proto3.getEnumType(ShardReplicationError_Type) },
        { no: 2, name: 'tablet_alias', kind: 'message', T: TabletAlias },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ShardReplicationError {
        return new ShardReplicationError().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ShardReplicationError {
        return new ShardReplicationError().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ShardReplicationError {
        return new ShardReplicationError().fromJsonString(jsonString, options);
    }

    static equals(
        a: ShardReplicationError | PlainMessage<ShardReplicationError> | undefined,
        b: ShardReplicationError | PlainMessage<ShardReplicationError> | undefined,
    ): boolean {
        return proto3.util.equals(ShardReplicationError, a, b);
    }
}

/**
 * @generated from enum topodata.ShardReplicationError.Type
 */
export enum ShardReplicationError_Type {
    /**
     * UNKNOWN is not a valid value.
     *
     * @generated from enum value: UNKNOWN = 0;
     */
    UNKNOWN = 0,

    /**
     * NOT_FOUND occurs when a tablet is in the ShardReplication record
     * but does not exist in the topology.
     *
     * @generated from enum value: NOT_FOUND = 1;
     */
    NOT_FOUND = 1,

    /**
     * TOPOLOGY_MISMATCH occurs when a tablet is in the replication graph and
     * exists in the topology, but at least one of the Keyspace, Shard, or Cell
     * fields for that tablet does not match the ShardReplication record.
     *
     * @generated from enum value: TOPOLOGY_MISMATCH = 2;
     */
    TOPOLOGY_MISMATCH = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ShardReplicationError_Type)
proto3.util.setEnumType(ShardReplicationError_Type, 'topodata.ShardReplicationError.Type', [
    { no: 0, name: 'UNKNOWN' },
    { no: 1, name: 'NOT_FOUND' },
    { no: 2, name: 'TOPOLOGY_MISMATCH' },
]);

/**
 * ShardReference is used as a pointer from a SrvKeyspace to a Shard
 *
 * @generated from message topodata.ShardReference
 */
export class ShardReference extends Message<ShardReference> {
    /**
     * Copied from Shard.
     *
     * @generated from field: string name = 1;
     */
    name = '';

    /**
     * Disable query serving in this shard
     *
     * @generated from field: topodata.KeyRange key_range = 2;
     */
    keyRange?: KeyRange;

    constructor(data?: PartialMessage<ShardReference>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.ShardReference';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'key_range', kind: 'message', T: KeyRange },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShardReference {
        return new ShardReference().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShardReference {
        return new ShardReference().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShardReference {
        return new ShardReference().fromJsonString(jsonString, options);
    }

    static equals(
        a: ShardReference | PlainMessage<ShardReference> | undefined,
        b: ShardReference | PlainMessage<ShardReference> | undefined,
    ): boolean {
        return proto3.util.equals(ShardReference, a, b);
    }
}

/**
 * ShardTabletControl is used as a pointer from a SrvKeyspace to a Shard
 *
 * @generated from message topodata.ShardTabletControl
 */
export class ShardTabletControl extends Message<ShardTabletControl> {
    /**
     * Copied from Shard.
     *
     * @generated from field: string name = 1;
     */
    name = '';

    /**
     * @generated from field: topodata.KeyRange key_range = 2;
     */
    keyRange?: KeyRange;

    /**
     * Disable query serving in this shard
     *
     * @generated from field: bool query_service_disabled = 3;
     */
    queryServiceDisabled = false;

    constructor(data?: PartialMessage<ShardTabletControl>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.ShardTabletControl';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'key_range', kind: 'message', T: KeyRange },
        { no: 3, name: 'query_service_disabled', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShardTabletControl {
        return new ShardTabletControl().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShardTabletControl {
        return new ShardTabletControl().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ShardTabletControl {
        return new ShardTabletControl().fromJsonString(jsonString, options);
    }

    static equals(
        a: ShardTabletControl | PlainMessage<ShardTabletControl> | undefined,
        b: ShardTabletControl | PlainMessage<ShardTabletControl> | undefined,
    ): boolean {
        return proto3.util.equals(ShardTabletControl, a, b);
    }
}

/**
 * ThrottledAppRule defines an app-specific throttling rule, with expiration.
 *
 * @generated from message topodata.ThrottledAppRule
 */
export class ThrottledAppRule extends Message<ThrottledAppRule> {
    /**
     * Name of the app to be throttled, e.g. "vreplication" or "online-ddl"
     *
     * @generated from field: string name = 1;
     */
    name = '';

    /**
     * Ratio defines how much the app should be throttled, range [0.0...1.0]. 1.0 means fully throttled. 0.0 means not throttled at all.
     * Negative values are reserved for a future implementation.
     *
     * @generated from field: double ratio = 2;
     */
    ratio = 0;

    /**
     * ExpiresAt is the time at which the rule expires.
     *
     * @generated from field: vttime.Time expires_at = 3;
     */
    expiresAt?: Time;

    /**
     * Exempt indicates the app should never be throttled, even if the throttler is, in general, throttling other apps.
     *
     * @generated from field: bool exempt = 4;
     */
    exempt = false;

    constructor(data?: PartialMessage<ThrottledAppRule>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.ThrottledAppRule';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'name', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'ratio', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
        { no: 3, name: 'expires_at', kind: 'message', T: Time },
        { no: 4, name: 'exempt', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ThrottledAppRule {
        return new ThrottledAppRule().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ThrottledAppRule {
        return new ThrottledAppRule().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ThrottledAppRule {
        return new ThrottledAppRule().fromJsonString(jsonString, options);
    }

    static equals(
        a: ThrottledAppRule | PlainMessage<ThrottledAppRule> | undefined,
        b: ThrottledAppRule | PlainMessage<ThrottledAppRule> | undefined,
    ): boolean {
        return proto3.util.equals(ThrottledAppRule, a, b);
    }
}

/**
 * @generated from message topodata.ThrottlerConfig
 */
export class ThrottlerConfig extends Message<ThrottlerConfig> {
    /**
     * Enabled indicates that the throttler is actually checking state for
     * requests. When disabled, it automatically returns 200 OK for all
     * checks.
     *
     * @generated from field: bool enabled = 1;
     */
    enabled = false;

    /**
     * Threshold is the threshold for either the default check (heartbeat
     * lag) or custom check.
     *
     * @generated from field: double threshold = 2;
     */
    threshold = 0;

    /**
     * CustomQuery is an optional query that overrides the default check
     * query.
     *
     * @generated from field: string custom_query = 3;
     */
    customQuery = '';

    /**
     * CheckAsCheckSelf indicates whether a throttler /check request
     * should behave like a /check-self.
     *
     * @generated from field: bool check_as_check_self = 4;
     */
    checkAsCheckSelf = false;

    /**
     * ThrottledApps is a map of rules for app-specific throttling
     *
     * @generated from field: map<string, topodata.ThrottledAppRule> throttled_apps = 5;
     */
    throttledApps: { [key: string]: ThrottledAppRule } = {};

    /**
     * AppCheckedMetrics maps app names to the list of metrics that should be checked for that app
     *
     * @generated from field: map<string, topodata.ThrottlerConfig.MetricNames> app_checked_metrics = 6;
     */
    appCheckedMetrics: { [key: string]: ThrottlerConfig_MetricNames } = {};

    /**
     * MetricThresholds maps metric names to the threshold values that should be used for that metric
     *
     * @generated from field: map<string, double> metric_thresholds = 7;
     */
    metricThresholds: { [key: string]: number } = {};

    constructor(data?: PartialMessage<ThrottlerConfig>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.ThrottlerConfig';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'enabled', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        { no: 2, name: 'threshold', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
        { no: 3, name: 'custom_query', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 4, name: 'check_as_check_self', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        {
            no: 5,
            name: 'throttled_apps',
            kind: 'map',
            K: 9 /* ScalarType.STRING */,
            V: { kind: 'message', T: ThrottledAppRule },
        },
        {
            no: 6,
            name: 'app_checked_metrics',
            kind: 'map',
            K: 9 /* ScalarType.STRING */,
            V: { kind: 'message', T: ThrottlerConfig_MetricNames },
        },
        {
            no: 7,
            name: 'metric_thresholds',
            kind: 'map',
            K: 9 /* ScalarType.STRING */,
            V: { kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
        },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ThrottlerConfig {
        return new ThrottlerConfig().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ThrottlerConfig {
        return new ThrottlerConfig().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ThrottlerConfig {
        return new ThrottlerConfig().fromJsonString(jsonString, options);
    }

    static equals(
        a: ThrottlerConfig | PlainMessage<ThrottlerConfig> | undefined,
        b: ThrottlerConfig | PlainMessage<ThrottlerConfig> | undefined,
    ): boolean {
        return proto3.util.equals(ThrottlerConfig, a, b);
    }
}

/**
 * @generated from message topodata.ThrottlerConfig.MetricNames
 */
export class ThrottlerConfig_MetricNames extends Message<ThrottlerConfig_MetricNames> {
    /**
     * @generated from field: repeated string names = 1;
     */
    names: string[] = [];

    constructor(data?: PartialMessage<ThrottlerConfig_MetricNames>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.ThrottlerConfig.MetricNames';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'names', kind: 'scalar', T: 9 /* ScalarType.STRING */, repeated: true },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ThrottlerConfig_MetricNames {
        return new ThrottlerConfig_MetricNames().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ThrottlerConfig_MetricNames {
        return new ThrottlerConfig_MetricNames().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ThrottlerConfig_MetricNames {
        return new ThrottlerConfig_MetricNames().fromJsonString(jsonString, options);
    }

    static equals(
        a: ThrottlerConfig_MetricNames | PlainMessage<ThrottlerConfig_MetricNames> | undefined,
        b: ThrottlerConfig_MetricNames | PlainMessage<ThrottlerConfig_MetricNames> | undefined,
    ): boolean {
        return proto3.util.equals(ThrottlerConfig_MetricNames, a, b);
    }
}

/**
 * SrvKeyspace is a rollup node for the keyspace itself.
 *
 * @generated from message topodata.SrvKeyspace
 */
export class SrvKeyspace extends Message<SrvKeyspace> {
    /**
     * The partitions this keyspace is serving, per tablet type.
     *
     * @generated from field: repeated topodata.SrvKeyspace.KeyspacePartition partitions = 1;
     */
    partitions: SrvKeyspace_KeyspacePartition[] = [];

    /**
     * ThrottlerConfig has the configuration for the tablet server's
     * lag throttler, and applies to the entire keyspace, across all
     * shards and tablets. This is copied from the global keyspace
     * object.
     *
     * @generated from field: topodata.ThrottlerConfig throttler_config = 6;
     */
    throttlerConfig?: ThrottlerConfig;

    constructor(data?: PartialMessage<SrvKeyspace>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.SrvKeyspace';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        {
            no: 1,
            name: 'partitions',
            kind: 'message',
            T: SrvKeyspace_KeyspacePartition,
            repeated: true,
        },
        { no: 6, name: 'throttler_config', kind: 'message', T: ThrottlerConfig },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SrvKeyspace {
        return new SrvKeyspace().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SrvKeyspace {
        return new SrvKeyspace().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SrvKeyspace {
        return new SrvKeyspace().fromJsonString(jsonString, options);
    }

    static equals(
        a: SrvKeyspace | PlainMessage<SrvKeyspace> | undefined,
        b: SrvKeyspace | PlainMessage<SrvKeyspace> | undefined,
    ): boolean {
        return proto3.util.equals(SrvKeyspace, a, b);
    }
}

/**
 * @generated from message topodata.SrvKeyspace.KeyspacePartition
 */
export class SrvKeyspace_KeyspacePartition extends Message<SrvKeyspace_KeyspacePartition> {
    /**
     * The type this partition applies to.
     *
     * @generated from field: topodata.TabletType served_type = 1;
     */
    servedType = TabletType.UNKNOWN;

    /**
     * List of non-overlapping continuous shards sorted by range.
     *
     * @generated from field: repeated topodata.ShardReference shard_references = 2;
     */
    shardReferences: ShardReference[] = [];

    /**
     * List of shard tablet controls
     *
     * @generated from field: repeated topodata.ShardTabletControl shard_tablet_controls = 3;
     */
    shardTabletControls: ShardTabletControl[] = [];

    constructor(data?: PartialMessage<SrvKeyspace_KeyspacePartition>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.SrvKeyspace.KeyspacePartition';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'served_type', kind: 'enum', T: proto3.getEnumType(TabletType) },
        { no: 2, name: 'shard_references', kind: 'message', T: ShardReference, repeated: true },
        {
            no: 3,
            name: 'shard_tablet_controls',
            kind: 'message',
            T: ShardTabletControl,
            repeated: true,
        },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): SrvKeyspace_KeyspacePartition {
        return new SrvKeyspace_KeyspacePartition().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): SrvKeyspace_KeyspacePartition {
        return new SrvKeyspace_KeyspacePartition().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): SrvKeyspace_KeyspacePartition {
        return new SrvKeyspace_KeyspacePartition().fromJsonString(jsonString, options);
    }

    static equals(
        a: SrvKeyspace_KeyspacePartition | PlainMessage<SrvKeyspace_KeyspacePartition> | undefined,
        b: SrvKeyspace_KeyspacePartition | PlainMessage<SrvKeyspace_KeyspacePartition> | undefined,
    ): boolean {
        return proto3.util.equals(SrvKeyspace_KeyspacePartition, a, b);
    }
}

/**
 * CellInfo contains information about a cell. CellInfo objects are
 * stored in the global topology server, and describe how to reach
 * local topology servers.
 *
 * @generated from message topodata.CellInfo
 */
export class CellInfo extends Message<CellInfo> {
    /**
     * ServerAddress contains the address of the server for the cell.
     * The syntax of this field is topology implementation specific.
     * For instance, for Zookeeper, it is a comma-separated list of
     * server addresses.
     *
     * @generated from field: string server_address = 1;
     */
    serverAddress = '';

    /**
     * Root is the path to store data in. It is only used when talking
     * to server_address.
     *
     * @generated from field: string root = 2;
     */
    root = '';

    constructor(data?: PartialMessage<CellInfo>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.CellInfo';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'server_address', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'root', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CellInfo {
        return new CellInfo().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CellInfo {
        return new CellInfo().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CellInfo {
        return new CellInfo().fromJsonString(jsonString, options);
    }

    static equals(
        a: CellInfo | PlainMessage<CellInfo> | undefined,
        b: CellInfo | PlainMessage<CellInfo> | undefined,
    ): boolean {
        return proto3.util.equals(CellInfo, a, b);
    }
}

/**
 * CellsAlias
 *
 * @generated from message topodata.CellsAlias
 */
export class CellsAlias extends Message<CellsAlias> {
    /**
     * Cells that map to this alias
     *
     * @generated from field: repeated string cells = 2;
     */
    cells: string[] = [];

    constructor(data?: PartialMessage<CellsAlias>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.CellsAlias';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 2, name: 'cells', kind: 'scalar', T: 9 /* ScalarType.STRING */, repeated: true },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CellsAlias {
        return new CellsAlias().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CellsAlias {
        return new CellsAlias().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CellsAlias {
        return new CellsAlias().fromJsonString(jsonString, options);
    }

    static equals(
        a: CellsAlias | PlainMessage<CellsAlias> | undefined,
        b: CellsAlias | PlainMessage<CellsAlias> | undefined,
    ): boolean {
        return proto3.util.equals(CellsAlias, a, b);
    }
}

/**
 * @generated from message topodata.TopoConfig
 */
export class TopoConfig extends Message<TopoConfig> {
    /**
     * @generated from field: string topo_type = 1;
     */
    topoType = '';

    /**
     * @generated from field: string server = 2;
     */
    server = '';

    /**
     * @generated from field: string root = 3;
     */
    root = '';

    constructor(data?: PartialMessage<TopoConfig>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.TopoConfig';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'topo_type', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'server', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 3, name: 'root', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TopoConfig {
        return new TopoConfig().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TopoConfig {
        return new TopoConfig().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TopoConfig {
        return new TopoConfig().fromJsonString(jsonString, options);
    }

    static equals(
        a: TopoConfig | PlainMessage<TopoConfig> | undefined,
        b: TopoConfig | PlainMessage<TopoConfig> | undefined,
    ): boolean {
        return proto3.util.equals(TopoConfig, a, b);
    }
}

/**
 * @generated from message topodata.ExternalVitessCluster
 */
export class ExternalVitessCluster extends Message<ExternalVitessCluster> {
    /**
     * @generated from field: topodata.TopoConfig topo_config = 1;
     */
    topoConfig?: TopoConfig;

    constructor(data?: PartialMessage<ExternalVitessCluster>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.ExternalVitessCluster';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'topo_config', kind: 'message', T: TopoConfig },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ExternalVitessCluster {
        return new ExternalVitessCluster().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ExternalVitessCluster {
        return new ExternalVitessCluster().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ExternalVitessCluster {
        return new ExternalVitessCluster().fromJsonString(jsonString, options);
    }

    static equals(
        a: ExternalVitessCluster | PlainMessage<ExternalVitessCluster> | undefined,
        b: ExternalVitessCluster | PlainMessage<ExternalVitessCluster> | undefined,
    ): boolean {
        return proto3.util.equals(ExternalVitessCluster, a, b);
    }
}

/**
 * ExternalClusters
 *
 * @generated from message topodata.ExternalClusters
 */
export class ExternalClusters extends Message<ExternalClusters> {
    /**
     * @generated from field: repeated topodata.ExternalVitessCluster vitess_cluster = 1;
     */
    vitessCluster: ExternalVitessCluster[] = [];

    constructor(data?: PartialMessage<ExternalClusters>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'topodata.ExternalClusters';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        {
            no: 1,
            name: 'vitess_cluster',
            kind: 'message',
            T: ExternalVitessCluster,
            repeated: true,
        },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExternalClusters {
        return new ExternalClusters().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExternalClusters {
        return new ExternalClusters().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ExternalClusters {
        return new ExternalClusters().fromJsonString(jsonString, options);
    }

    static equals(
        a: ExternalClusters | PlainMessage<ExternalClusters> | undefined,
        b: ExternalClusters | PlainMessage<ExternalClusters> | undefined,
    ): boolean {
        return proto3.util.equals(ExternalClusters, a, b);
    }
}
