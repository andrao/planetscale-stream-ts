//
//Copyright 2019 The Vitess Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// Data definitions for service vtgateservice.

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file vtgate.proto (package vtgate, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import {
    Message,
    proto3,
    protoInt64,
    type BinaryReadOptions,
    type FieldList,
    type JsonReadOptions,
    type JsonValue,
    type PartialMessage,
    type PlainMessage,
} from '@bufbuild/protobuf';
import { Filter, VEvent, VGtid } from './binlogdata_pb.js';
import {
    BindVariable,
    BoundQuery,
    ExecuteOptions,
    Field,
    QueryResult,
    QueryWarning,
    ResultWithError,
    Target,
} from './query_pb.js';
import { TabletAlias, TabletType } from './topodata_pb.js';
import { CallerID, RPCError } from './vtrpc_pb.js';

/**
 * TransactionMode controls the execution of distributed transaction
 * across multiple shards.
 *
 * @generated from enum vtgate.TransactionMode
 */
export enum TransactionMode {
    /**
     * UNSPECIFIED uses the transaction mode set by the VTGate flag 'transaction_mode'.
     *
     * @generated from enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,

    /**
     * SINGLE disallows distributed transactions.
     *
     * @generated from enum value: SINGLE = 1;
     */
    SINGLE = 1,

    /**
     * MULTI allows distributed transactions with best effort commit.
     *
     * @generated from enum value: MULTI = 2;
     */
    MULTI = 2,

    /**
     * TWOPC is for distributed transactions with atomic commits.
     *
     * @generated from enum value: TWOPC = 3;
     */
    TWOPC = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(TransactionMode)
proto3.util.setEnumType(TransactionMode, 'vtgate.TransactionMode', [
    { no: 0, name: 'UNSPECIFIED' },
    { no: 1, name: 'SINGLE' },
    { no: 2, name: 'MULTI' },
    { no: 3, name: 'TWOPC' },
]);

/**
 * CommitOrder is used to designate which of the ShardSessions
 * get used for transactions.
 *
 * @generated from enum vtgate.CommitOrder
 */
export enum CommitOrder {
    /**
     * NORMAL is the default commit order.
     *
     * @generated from enum value: NORMAL = 0;
     */
    NORMAL = 0,

    /**
     * PRE is used to designate pre_sessions.
     *
     * @generated from enum value: PRE = 1;
     */
    PRE = 1,

    /**
     * POST is used to designate post_sessions.
     *
     * @generated from enum value: POST = 2;
     */
    POST = 2,

    /**
     * AUTOCOMMIT is used to run the statement as autocommitted transaction.
     *
     * @generated from enum value: AUTOCOMMIT = 3;
     */
    AUTOCOMMIT = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(CommitOrder)
proto3.util.setEnumType(CommitOrder, 'vtgate.CommitOrder', [
    { no: 0, name: 'NORMAL' },
    { no: 1, name: 'PRE' },
    { no: 2, name: 'POST' },
    { no: 3, name: 'AUTOCOMMIT' },
]);

/**
 * Session objects are exchanged like cookies through various
 * calls to VTGate. The behavior differs between V2 & V3 APIs.
 * V3 APIs are Execute, ExecuteBatch and StreamExecute. All
 * other APIs are V2. For the V3 APIs, the session
 * must be sent with every call to Execute or ExecuteBatch.
 * For the V2 APIs, Begin does not accept a session. It instead
 * returns a brand new one with in_transaction set to true.
 * After a call to Commit or Rollback, the session can be
 * discarded. If you're not in a transaction, Session is
 * an optional parameter for the V2 APIs.
 *
 * @generated from message vtgate.Session
 */
export class Session extends Message<Session> {
    /**
     * in_transaction is set to true if the session is in a transaction.
     *
     * @generated from field: bool in_transaction = 1;
     */
    inTransaction = false;

    /**
     * shard_sessions keep track of per-shard transaction info.
     *
     * @generated from field: repeated vtgate.Session.ShardSession shard_sessions = 2;
     */
    shardSessions: Session_ShardSession[] = [];

    /**
     * autocommit specifies if the session is in autocommit mode.
     * This is used only for V3.
     *
     * @generated from field: bool autocommit = 4;
     */
    autocommit = false;

    /**
     * target_string is the target expressed as a string. Valid
     * names are: keyspace:shard@target, keyspace@target or @target.
     * This is used only for V3.
     *
     * @generated from field: string target_string = 5;
     */
    targetString = '';

    /**
     * options is used only for V3.
     *
     * @generated from field: query.ExecuteOptions options = 6;
     */
    options?: ExecuteOptions;

    /**
     * transaction_mode specifies the current transaction mode.
     *
     * @generated from field: vtgate.TransactionMode transaction_mode = 7;
     */
    transactionMode = TransactionMode.UNSPECIFIED;

    /**
     * warnings contains non-fatal warnings from the previous query
     *
     * @generated from field: repeated query.QueryWarning warnings = 8;
     */
    warnings: QueryWarning[] = [];

    /**
     * pre_sessions contains sessions that have to be committed first.
     *
     * @generated from field: repeated vtgate.Session.ShardSession pre_sessions = 9;
     */
    preSessions: Session_ShardSession[] = [];

    /**
     * post_sessions contains sessions that have to be committed last.
     *
     * @generated from field: repeated vtgate.Session.ShardSession post_sessions = 10;
     */
    postSessions: Session_ShardSession[] = [];

    /**
     * last_insert_id keeps track of the last seen insert_id for this session
     *
     * @generated from field: uint64 last_insert_id = 11;
     */
    lastInsertId = protoInt64.zero;

    /**
     * found_rows keeps track of how many rows the last query returned
     *
     * @generated from field: uint64 found_rows = 12;
     */
    foundRows = protoInt64.zero;

    /**
     * user_defined_variables contains all the @variables defined for this session
     *
     * @generated from field: map<string, query.BindVariable> user_defined_variables = 13;
     */
    userDefinedVariables: { [key: string]: BindVariable } = {};

    /**
     * system_variables keeps track of all session variables set for this connection
     * TODO: systay should we keep this so we can apply it ordered?
     *
     * @generated from field: map<string, string> system_variables = 14;
     */
    systemVariables: { [key: string]: string } = {};

    /**
     * row_count keeps track of the last seen rows affected for this session
     *
     * @generated from field: int64 row_count = 15;
     */
    rowCount = protoInt64.zero;

    /**
     * Stores savepoint and release savepoint calls inside a transaction
     * and is reset once transaction is committed or rolled back.
     *
     * @generated from field: repeated string savepoints = 16;
     */
    savepoints: string[] = [];

    /**
     * in_reserved_conn is set to true if the session should be using reserved connections.
     *
     * @generated from field: bool in_reserved_conn = 17;
     */
    inReservedConn = false;

    /**
     * lock_session keep tracks of shard on which the lock query is sent.
     *
     * @generated from field: vtgate.Session.ShardSession lock_session = 18;
     */
    lockSession?: Session_ShardSession;

    /**
     * last_lock_heartbeat keep tracks of when last lock heartbeat was sent.
     *
     * @generated from field: int64 last_lock_heartbeat = 19;
     */
    lastLockHeartbeat = protoInt64.zero;

    /**
     * read_after_write tracks the ReadAfterWrite settings for this session.
     *
     * @generated from field: vtgate.ReadAfterWrite read_after_write = 20;
     */
    readAfterWrite?: ReadAfterWrite;

    /**
     * DDL strategy
     *
     * @generated from field: string DDLStrategy = 21;
     */
    DDLStrategy = '';

    /**
     * Session UUID
     *
     * @generated from field: string SessionUUID = 22;
     */
    SessionUUID = '';

    /**
     * enable_system_settings defines if we can use reserved connections.
     *
     * @generated from field: bool enable_system_settings = 23;
     */
    enableSystemSettings = false;

    /**
     * @generated from field: map<string, int64> advisory_lock = 24;
     */
    advisoryLock: { [key: string]: bigint } = {};

    /**
     * query_timeout is the maximum amount of time a query is permitted to run
     *
     * @generated from field: int64 query_timeout = 25;
     */
    queryTimeout = protoInt64.zero;

    /**
     * @generated from field: map<string, vtgate.PrepareData> prepare_statement = 26;
     */
    prepareStatement: { [key: string]: PrepareData } = {};

    /**
     * MigrationContext
     *
     * @generated from field: string migration_context = 27;
     */
    migrationContext = '';

    constructor(data?: PartialMessage<Session>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.Session';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'in_transaction', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        { no: 2, name: 'shard_sessions', kind: 'message', T: Session_ShardSession, repeated: true },
        { no: 4, name: 'autocommit', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        { no: 5, name: 'target_string', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 6, name: 'options', kind: 'message', T: ExecuteOptions },
        { no: 7, name: 'transaction_mode', kind: 'enum', T: proto3.getEnumType(TransactionMode) },
        { no: 8, name: 'warnings', kind: 'message', T: QueryWarning, repeated: true },
        { no: 9, name: 'pre_sessions', kind: 'message', T: Session_ShardSession, repeated: true },
        { no: 10, name: 'post_sessions', kind: 'message', T: Session_ShardSession, repeated: true },
        { no: 11, name: 'last_insert_id', kind: 'scalar', T: 4 /* ScalarType.UINT64 */ },
        { no: 12, name: 'found_rows', kind: 'scalar', T: 4 /* ScalarType.UINT64 */ },
        {
            no: 13,
            name: 'user_defined_variables',
            kind: 'map',
            K: 9 /* ScalarType.STRING */,
            V: { kind: 'message', T: BindVariable },
        },
        {
            no: 14,
            name: 'system_variables',
            kind: 'map',
            K: 9 /* ScalarType.STRING */,
            V: { kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        },
        { no: 15, name: 'row_count', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        {
            no: 16,
            name: 'savepoints',
            kind: 'scalar',
            T: 9 /* ScalarType.STRING */,
            repeated: true,
        },
        { no: 17, name: 'in_reserved_conn', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        { no: 18, name: 'lock_session', kind: 'message', T: Session_ShardSession },
        { no: 19, name: 'last_lock_heartbeat', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 20, name: 'read_after_write', kind: 'message', T: ReadAfterWrite },
        { no: 21, name: 'DDLStrategy', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 22, name: 'SessionUUID', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 23, name: 'enable_system_settings', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        {
            no: 24,
            name: 'advisory_lock',
            kind: 'map',
            K: 9 /* ScalarType.STRING */,
            V: { kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        },
        { no: 25, name: 'query_timeout', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        {
            no: 26,
            name: 'prepare_statement',
            kind: 'map',
            K: 9 /* ScalarType.STRING */,
            V: { kind: 'message', T: PrepareData },
        },
        { no: 27, name: 'migration_context', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Session {
        return new Session().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Session {
        return new Session().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Session {
        return new Session().fromJsonString(jsonString, options);
    }

    static equals(
        a: Session | PlainMessage<Session> | undefined,
        b: Session | PlainMessage<Session> | undefined,
    ): boolean {
        return proto3.util.equals(Session, a, b);
    }
}

/**
 * @generated from message vtgate.Session.ShardSession
 */
export class Session_ShardSession extends Message<Session_ShardSession> {
    /**
     * @generated from field: query.Target target = 1;
     */
    target?: Target;

    /**
     * @generated from field: int64 transaction_id = 2;
     */
    transactionId = protoInt64.zero;

    /**
     * @generated from field: topodata.TabletAlias tablet_alias = 3;
     */
    tabletAlias?: TabletAlias;

    /**
     * reserved connection if a dedicated connection is needed
     *
     * @generated from field: int64 reserved_id = 4;
     */
    reservedId = protoInt64.zero;

    /**
     * @generated from field: bool vindex_only = 5;
     */
    vindexOnly = false;

    constructor(data?: PartialMessage<Session_ShardSession>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.Session.ShardSession';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'target', kind: 'message', T: Target },
        { no: 2, name: 'transaction_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 3, name: 'tablet_alias', kind: 'message', T: TabletAlias },
        { no: 4, name: 'reserved_id', kind: 'scalar', T: 3 /* ScalarType.INT64 */ },
        { no: 5, name: 'vindex_only', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): Session_ShardSession {
        return new Session_ShardSession().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): Session_ShardSession {
        return new Session_ShardSession().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): Session_ShardSession {
        return new Session_ShardSession().fromJsonString(jsonString, options);
    }

    static equals(
        a: Session_ShardSession | PlainMessage<Session_ShardSession> | undefined,
        b: Session_ShardSession | PlainMessage<Session_ShardSession> | undefined,
    ): boolean {
        return proto3.util.equals(Session_ShardSession, a, b);
    }
}

/**
 * PrepareData keeps the prepared statement and other information related for execution of it.
 *
 * @generated from message vtgate.PrepareData
 */
export class PrepareData extends Message<PrepareData> {
    /**
     * @generated from field: string prepare_statement = 1;
     */
    prepareStatement = '';

    /**
     * @generated from field: int32 params_count = 2;
     */
    paramsCount = 0;

    constructor(data?: PartialMessage<PrepareData>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.PrepareData';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'prepare_statement', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'params_count', kind: 'scalar', T: 5 /* ScalarType.INT32 */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrepareData {
        return new PrepareData().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrepareData {
        return new PrepareData().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrepareData {
        return new PrepareData().fromJsonString(jsonString, options);
    }

    static equals(
        a: PrepareData | PlainMessage<PrepareData> | undefined,
        b: PrepareData | PlainMessage<PrepareData> | undefined,
    ): boolean {
        return proto3.util.equals(PrepareData, a, b);
    }
}

/**
 * ReadAfterWrite contains information regarding gtid set and timeout
 * Also if the gtid information needs to be passed to client.
 *
 * @generated from message vtgate.ReadAfterWrite
 */
export class ReadAfterWrite extends Message<ReadAfterWrite> {
    /**
     * @generated from field: string read_after_write_gtid = 1;
     */
    readAfterWriteGtid = '';

    /**
     * @generated from field: double read_after_write_timeout = 2;
     */
    readAfterWriteTimeout = 0;

    /**
     * @generated from field: bool session_track_gtids = 3;
     */
    sessionTrackGtids = false;

    constructor(data?: PartialMessage<ReadAfterWrite>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.ReadAfterWrite';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'read_after_write_gtid', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 2, name: 'read_after_write_timeout', kind: 'scalar', T: 1 /* ScalarType.DOUBLE */ },
        { no: 3, name: 'session_track_gtids', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadAfterWrite {
        return new ReadAfterWrite().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadAfterWrite {
        return new ReadAfterWrite().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadAfterWrite {
        return new ReadAfterWrite().fromJsonString(jsonString, options);
    }

    static equals(
        a: ReadAfterWrite | PlainMessage<ReadAfterWrite> | undefined,
        b: ReadAfterWrite | PlainMessage<ReadAfterWrite> | undefined,
    ): boolean {
        return proto3.util.equals(ReadAfterWrite, a, b);
    }
}

/**
 * ExecuteRequest is the payload to Execute.
 *
 * @generated from message vtgate.ExecuteRequest
 */
export class ExecuteRequest extends Message<ExecuteRequest> {
    /**
     * caller_id identifies the caller. This is the effective caller ID,
     * set by the application to further identify the caller.
     *
     * @generated from field: vtrpc.CallerID caller_id = 1;
     */
    callerId?: CallerID;

    /**
     * session carries the session state.
     *
     * @generated from field: vtgate.Session session = 2;
     */
    session?: Session;

    /**
     * query is the query and bind variables to execute.
     *
     * @generated from field: query.BoundQuery query = 3;
     */
    query?: BoundQuery;

    constructor(data?: PartialMessage<ExecuteRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.ExecuteRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'session', kind: 'message', T: Session },
        { no: 3, name: 'query', kind: 'message', T: BoundQuery },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteRequest {
        return new ExecuteRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteRequest {
        return new ExecuteRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteRequest {
        return new ExecuteRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: ExecuteRequest | PlainMessage<ExecuteRequest> | undefined,
        b: ExecuteRequest | PlainMessage<ExecuteRequest> | undefined,
    ): boolean {
        return proto3.util.equals(ExecuteRequest, a, b);
    }
}

/**
 * ExecuteResponse is the returned value from Execute.
 *
 * @generated from message vtgate.ExecuteResponse
 */
export class ExecuteResponse extends Message<ExecuteResponse> {
    /**
     * error contains an application level error if necessary. Note the
     * session may have changed, even when an error is returned (for
     * instance if a database integrity error happened).
     *
     * @generated from field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;

    /**
     * session is the updated session information.
     *
     * @generated from field: vtgate.Session session = 2;
     */
    session?: Session;

    /**
     * result contains the query result, only set if error is unset.
     *
     * @generated from field: query.QueryResult result = 3;
     */
    result?: QueryResult;

    constructor(data?: PartialMessage<ExecuteResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.ExecuteResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'error', kind: 'message', T: RPCError },
        { no: 2, name: 'session', kind: 'message', T: Session },
        { no: 3, name: 'result', kind: 'message', T: QueryResult },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteResponse {
        return new ExecuteResponse().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteResponse {
        return new ExecuteResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteResponse {
        return new ExecuteResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: ExecuteResponse | PlainMessage<ExecuteResponse> | undefined,
        b: ExecuteResponse | PlainMessage<ExecuteResponse> | undefined,
    ): boolean {
        return proto3.util.equals(ExecuteResponse, a, b);
    }
}

/**
 * ExecuteBatchRequest is the payload to ExecuteBatch.
 *
 * @generated from message vtgate.ExecuteBatchRequest
 */
export class ExecuteBatchRequest extends Message<ExecuteBatchRequest> {
    /**
     * caller_id identifies the caller. This is the effective caller ID,
     * set by the application to further identify the caller.
     *
     * @generated from field: vtrpc.CallerID caller_id = 1;
     */
    callerId?: CallerID;

    /**
     * session carries the session state.
     *
     * @generated from field: vtgate.Session session = 2;
     */
    session?: Session;

    /**
     * queries is a list of query and bind variables to execute.
     *
     * @generated from field: repeated query.BoundQuery queries = 3;
     */
    queries: BoundQuery[] = [];

    constructor(data?: PartialMessage<ExecuteBatchRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.ExecuteBatchRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'session', kind: 'message', T: Session },
        { no: 3, name: 'queries', kind: 'message', T: BoundQuery, repeated: true },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ExecuteBatchRequest {
        return new ExecuteBatchRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteBatchRequest {
        return new ExecuteBatchRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ExecuteBatchRequest {
        return new ExecuteBatchRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: ExecuteBatchRequest | PlainMessage<ExecuteBatchRequest> | undefined,
        b: ExecuteBatchRequest | PlainMessage<ExecuteBatchRequest> | undefined,
    ): boolean {
        return proto3.util.equals(ExecuteBatchRequest, a, b);
    }
}

/**
 * ExecuteBatchResponse is the returned value from ExecuteBatch.
 *
 * @generated from message vtgate.ExecuteBatchResponse
 */
export class ExecuteBatchResponse extends Message<ExecuteBatchResponse> {
    /**
     * error contains an application level error if necessary. Note the
     * session may have changed, even when an error is returned (for
     * instance if a database integrity error happened).
     *
     * @generated from field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;

    /**
     * session is the updated session information.
     *
     * @generated from field: vtgate.Session session = 2;
     */
    session?: Session;

    /**
     * results contains the query results, only set if application level error is unset.
     *
     * @generated from field: repeated query.ResultWithError results = 3;
     */
    results: ResultWithError[] = [];

    constructor(data?: PartialMessage<ExecuteBatchResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.ExecuteBatchResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'error', kind: 'message', T: RPCError },
        { no: 2, name: 'session', kind: 'message', T: Session },
        { no: 3, name: 'results', kind: 'message', T: ResultWithError, repeated: true },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ExecuteBatchResponse {
        return new ExecuteBatchResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ExecuteBatchResponse {
        return new ExecuteBatchResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ExecuteBatchResponse {
        return new ExecuteBatchResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: ExecuteBatchResponse | PlainMessage<ExecuteBatchResponse> | undefined,
        b: ExecuteBatchResponse | PlainMessage<ExecuteBatchResponse> | undefined,
    ): boolean {
        return proto3.util.equals(ExecuteBatchResponse, a, b);
    }
}

/**
 * StreamExecuteRequest is the payload to StreamExecute.
 *
 * @generated from message vtgate.StreamExecuteRequest
 */
export class StreamExecuteRequest extends Message<StreamExecuteRequest> {
    /**
     * caller_id identifies the caller. This is the effective caller ID,
     * set by the application to further identify the caller.
     *
     * @generated from field: vtrpc.CallerID caller_id = 1;
     */
    callerId?: CallerID;

    /**
     * query is the query and bind variables to execute.
     *
     * @generated from field: query.BoundQuery query = 2;
     */
    query?: BoundQuery;

    /**
     * session carries the session state.
     *
     * @generated from field: vtgate.Session session = 6;
     */
    session?: Session;

    constructor(data?: PartialMessage<StreamExecuteRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.StreamExecuteRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'query', kind: 'message', T: BoundQuery },
        { no: 6, name: 'session', kind: 'message', T: Session },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): StreamExecuteRequest {
        return new StreamExecuteRequest().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): StreamExecuteRequest {
        return new StreamExecuteRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): StreamExecuteRequest {
        return new StreamExecuteRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: StreamExecuteRequest | PlainMessage<StreamExecuteRequest> | undefined,
        b: StreamExecuteRequest | PlainMessage<StreamExecuteRequest> | undefined,
    ): boolean {
        return proto3.util.equals(StreamExecuteRequest, a, b);
    }
}

/**
 * StreamExecuteResponse is the returned value from StreamExecute.
 * The session is currently not returned because StreamExecute is
 * not expected to modify it.
 *
 * @generated from message vtgate.StreamExecuteResponse
 */
export class StreamExecuteResponse extends Message<StreamExecuteResponse> {
    /**
     * result contains the result data.
     * The first value contains only Fields information.
     * The next values contain the actual rows, a few values per result.
     *
     * @generated from field: query.QueryResult result = 1;
     */
    result?: QueryResult;

    /**
     * session is the updated session information.
     *
     * @generated from field: vtgate.Session session = 2;
     */
    session?: Session;

    constructor(data?: PartialMessage<StreamExecuteResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.StreamExecuteResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'result', kind: 'message', T: QueryResult },
        { no: 2, name: 'session', kind: 'message', T: Session },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): StreamExecuteResponse {
        return new StreamExecuteResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): StreamExecuteResponse {
        return new StreamExecuteResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): StreamExecuteResponse {
        return new StreamExecuteResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: StreamExecuteResponse | PlainMessage<StreamExecuteResponse> | undefined,
        b: StreamExecuteResponse | PlainMessage<StreamExecuteResponse> | undefined,
    ): boolean {
        return proto3.util.equals(StreamExecuteResponse, a, b);
    }
}

/**
 * ResolveTransactionRequest is the payload to ResolveTransaction.
 *
 * @generated from message vtgate.ResolveTransactionRequest
 */
export class ResolveTransactionRequest extends Message<ResolveTransactionRequest> {
    /**
     * caller_id identifies the caller. This is the effective caller ID,
     * set by the application to further identify the caller.
     *
     * @generated from field: vtrpc.CallerID caller_id = 1;
     */
    callerId?: CallerID;

    /**
     * dtid is the dtid of the transaction to be resolved.
     *
     * @generated from field: string dtid = 2;
     */
    dtid = '';

    constructor(data?: PartialMessage<ResolveTransactionRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.ResolveTransactionRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'dtid', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ResolveTransactionRequest {
        return new ResolveTransactionRequest().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ResolveTransactionRequest {
        return new ResolveTransactionRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ResolveTransactionRequest {
        return new ResolveTransactionRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: ResolveTransactionRequest | PlainMessage<ResolveTransactionRequest> | undefined,
        b: ResolveTransactionRequest | PlainMessage<ResolveTransactionRequest> | undefined,
    ): boolean {
        return proto3.util.equals(ResolveTransactionRequest, a, b);
    }
}

/**
 * ResolveTransactionResponse is the returned value from Rollback.
 *
 * @generated from message vtgate.ResolveTransactionResponse
 */
export class ResolveTransactionResponse extends Message<ResolveTransactionResponse> {
    constructor(data?: PartialMessage<ResolveTransactionResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.ResolveTransactionResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => []);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): ResolveTransactionResponse {
        return new ResolveTransactionResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): ResolveTransactionResponse {
        return new ResolveTransactionResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): ResolveTransactionResponse {
        return new ResolveTransactionResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: ResolveTransactionResponse | PlainMessage<ResolveTransactionResponse> | undefined,
        b: ResolveTransactionResponse | PlainMessage<ResolveTransactionResponse> | undefined,
    ): boolean {
        return proto3.util.equals(ResolveTransactionResponse, a, b);
    }
}

/**
 * @generated from message vtgate.VStreamFlags
 */
export class VStreamFlags extends Message<VStreamFlags> {
    /**
     * align streams
     *
     * @generated from field: bool minimize_skew = 1;
     */
    minimizeSkew = false;

    /**
     * how often heartbeats must be sent when idle (seconds)
     *
     * @generated from field: uint32 heartbeat_interval = 2;
     */
    heartbeatInterval = 0;

    /**
     * stop streams on a reshard (journal event)
     *
     * @generated from field: bool stop_on_reshard = 3;
     */
    stopOnReshard = false;

    /**
     * if specified, these cells (comma-separated) are used to pick source tablets from.
     * defaults to the cell of the vtgate serving the VStream API.
     *
     * @generated from field: string cells = 4;
     */
    cells = '';

    /**
     * @generated from field: string cell_preference = 5;
     */
    cellPreference = '';

    /**
     * @generated from field: string tablet_order = 6;
     */
    tabletOrder = '';

    /**
     * When set, all new row events from the `heartbeat` table, for all shards, in the sidecardb will be streamed.
     *
     * @generated from field: bool stream_keyspace_heartbeats = 7;
     */
    streamKeyspaceHeartbeats = false;

    /**
     * Include reshard journal events in the stream.
     *
     * @generated from field: bool include_reshard_journal_events = 8;
     */
    includeReshardJournalEvents = false;

    constructor(data?: PartialMessage<VStreamFlags>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.VStreamFlags';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'minimize_skew', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        { no: 2, name: 'heartbeat_interval', kind: 'scalar', T: 13 /* ScalarType.UINT32 */ },
        { no: 3, name: 'stop_on_reshard', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        { no: 4, name: 'cells', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 5, name: 'cell_preference', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 6, name: 'tablet_order', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
        { no: 7, name: 'stream_keyspace_heartbeats', kind: 'scalar', T: 8 /* ScalarType.BOOL */ },
        {
            no: 8,
            name: 'include_reshard_journal_events',
            kind: 'scalar',
            T: 8 /* ScalarType.BOOL */,
        },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VStreamFlags {
        return new VStreamFlags().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VStreamFlags {
        return new VStreamFlags().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VStreamFlags {
        return new VStreamFlags().fromJsonString(jsonString, options);
    }

    static equals(
        a: VStreamFlags | PlainMessage<VStreamFlags> | undefined,
        b: VStreamFlags | PlainMessage<VStreamFlags> | undefined,
    ): boolean {
        return proto3.util.equals(VStreamFlags, a, b);
    }
}

/**
 * VStreamRequest is the payload for VStream.
 *
 * @generated from message vtgate.VStreamRequest
 */
export class VStreamRequest extends Message<VStreamRequest> {
    /**
     * @generated from field: vtrpc.CallerID caller_id = 1;
     */
    callerId?: CallerID;

    /**
     * @generated from field: topodata.TabletType tablet_type = 2;
     */
    tabletType = TabletType.UNKNOWN;

    /**
     * position specifies the starting point of the bin log positions
     * as well as the keyspace-shards to pull events from.
     * position is of the form 'ks1:0@MySQL56/<mysql_pos>|ks2:-80@MySQL56/<mysql_pos>'.
     *
     * @generated from field: binlogdata.VGtid vgtid = 3;
     */
    vgtid?: VGtid;

    /**
     * @generated from field: binlogdata.Filter filter = 4;
     */
    filter?: Filter;

    /**
     * @generated from field: vtgate.VStreamFlags flags = 5;
     */
    flags?: VStreamFlags;

    constructor(data?: PartialMessage<VStreamRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.VStreamRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'tablet_type', kind: 'enum', T: proto3.getEnumType(TabletType) },
        { no: 3, name: 'vgtid', kind: 'message', T: VGtid },
        { no: 4, name: 'filter', kind: 'message', T: Filter },
        { no: 5, name: 'flags', kind: 'message', T: VStreamFlags },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VStreamRequest {
        return new VStreamRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VStreamRequest {
        return new VStreamRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VStreamRequest {
        return new VStreamRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: VStreamRequest | PlainMessage<VStreamRequest> | undefined,
        b: VStreamRequest | PlainMessage<VStreamRequest> | undefined,
    ): boolean {
        return proto3.util.equals(VStreamRequest, a, b);
    }
}

/**
 * VStreamResponse is streamed by VStream.
 *
 * @generated from message vtgate.VStreamResponse
 */
export class VStreamResponse extends Message<VStreamResponse> {
    /**
     * @generated from field: repeated binlogdata.VEvent events = 1;
     */
    events: VEvent[] = [];

    constructor(data?: PartialMessage<VStreamResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.VStreamResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'events', kind: 'message', T: VEvent, repeated: true },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VStreamResponse {
        return new VStreamResponse().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VStreamResponse {
        return new VStreamResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VStreamResponse {
        return new VStreamResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: VStreamResponse | PlainMessage<VStreamResponse> | undefined,
        b: VStreamResponse | PlainMessage<VStreamResponse> | undefined,
    ): boolean {
        return proto3.util.equals(VStreamResponse, a, b);
    }
}

/**
 * PrepareRequest is the payload to Prepare.
 *
 * @generated from message vtgate.PrepareRequest
 */
export class PrepareRequest extends Message<PrepareRequest> {
    /**
     * caller_id identifies the caller. This is the effective caller ID,
     * set by the application to further identify the caller.
     *
     * @generated from field: vtrpc.CallerID caller_id = 1;
     */
    callerId?: CallerID;

    /**
     * session carries the session state.
     *
     * @generated from field: vtgate.Session session = 2;
     */
    session?: Session;

    /**
     * query is the query and bind variables to execute.
     *
     * @generated from field: query.BoundQuery query = 3;
     */
    query?: BoundQuery;

    constructor(data?: PartialMessage<PrepareRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.PrepareRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'session', kind: 'message', T: Session },
        { no: 3, name: 'query', kind: 'message', T: BoundQuery },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrepareRequest {
        return new PrepareRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrepareRequest {
        return new PrepareRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrepareRequest {
        return new PrepareRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: PrepareRequest | PlainMessage<PrepareRequest> | undefined,
        b: PrepareRequest | PlainMessage<PrepareRequest> | undefined,
    ): boolean {
        return proto3.util.equals(PrepareRequest, a, b);
    }
}

/**
 * PrepareResponse is the returned value from Prepare.
 *
 * @generated from message vtgate.PrepareResponse
 */
export class PrepareResponse extends Message<PrepareResponse> {
    /**
     * error contains an application level error if necessary. Note the
     * session may have changed, even when an error is returned (for
     * instance if a database integrity error happened).
     *
     * @generated from field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;

    /**
     * session is the updated session information.
     *
     * @generated from field: vtgate.Session session = 2;
     */
    session?: Session;

    /**
     * fields contains the fields, only set if error is unset.
     *
     * @generated from field: repeated query.Field fields = 3;
     */
    fields: Field[] = [];

    constructor(data?: PartialMessage<PrepareResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.PrepareResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'error', kind: 'message', T: RPCError },
        { no: 2, name: 'session', kind: 'message', T: Session },
        { no: 3, name: 'fields', kind: 'message', T: Field, repeated: true },
    ]);

    static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrepareResponse {
        return new PrepareResponse().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrepareResponse {
        return new PrepareResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrepareResponse {
        return new PrepareResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: PrepareResponse | PlainMessage<PrepareResponse> | undefined,
        b: PrepareResponse | PlainMessage<PrepareResponse> | undefined,
    ): boolean {
        return proto3.util.equals(PrepareResponse, a, b);
    }
}

/**
 * CloseSessionRequest is the payload to CloseSession.
 *
 * @generated from message vtgate.CloseSessionRequest
 */
export class CloseSessionRequest extends Message<CloseSessionRequest> {
    /**
     * caller_id identifies the caller. This is the effective caller ID,
     * set by the application to further identify the caller.
     *
     * @generated from field: vtrpc.CallerID caller_id = 1;
     */
    callerId?: CallerID;

    /**
     * session carries the session state.
     *
     * @generated from field: vtgate.Session session = 2;
     */
    session?: Session;

    constructor(data?: PartialMessage<CloseSessionRequest>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.CloseSessionRequest';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'caller_id', kind: 'message', T: CallerID },
        { no: 2, name: 'session', kind: 'message', T: Session },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): CloseSessionRequest {
        return new CloseSessionRequest().fromBinary(bytes, options);
    }

    static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CloseSessionRequest {
        return new CloseSessionRequest().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): CloseSessionRequest {
        return new CloseSessionRequest().fromJsonString(jsonString, options);
    }

    static equals(
        a: CloseSessionRequest | PlainMessage<CloseSessionRequest> | undefined,
        b: CloseSessionRequest | PlainMessage<CloseSessionRequest> | undefined,
    ): boolean {
        return proto3.util.equals(CloseSessionRequest, a, b);
    }
}

/**
 * CloseSessionResponse is the returned value from CloseSession.
 *
 * @generated from message vtgate.CloseSessionResponse
 */
export class CloseSessionResponse extends Message<CloseSessionResponse> {
    /**
     * error contains an application level error if necessary. Note the
     * session may have changed, even when an error is returned (for
     * instance if a database integrity error happened).
     *
     * @generated from field: vtrpc.RPCError error = 1;
     */
    error?: RPCError;

    constructor(data?: PartialMessage<CloseSessionResponse>) {
        super();
        proto3.util.initPartial(data, this);
    }

    static readonly runtime: typeof proto3 = proto3;
    static readonly typeName = 'vtgate.CloseSessionResponse';
    static readonly fields: FieldList = proto3.util.newFieldList(() => [
        { no: 1, name: 'error', kind: 'message', T: RPCError },
    ]);

    static fromBinary(
        bytes: Uint8Array,
        options?: Partial<BinaryReadOptions>,
    ): CloseSessionResponse {
        return new CloseSessionResponse().fromBinary(bytes, options);
    }

    static fromJson(
        jsonValue: JsonValue,
        options?: Partial<JsonReadOptions>,
    ): CloseSessionResponse {
        return new CloseSessionResponse().fromJson(jsonValue, options);
    }

    static fromJsonString(
        jsonString: string,
        options?: Partial<JsonReadOptions>,
    ): CloseSessionResponse {
        return new CloseSessionResponse().fromJsonString(jsonString, options);
    }

    static equals(
        a: CloseSessionResponse | PlainMessage<CloseSessionResponse> | undefined,
        b: CloseSessionResponse | PlainMessage<CloseSessionResponse> | undefined,
    ): boolean {
        return proto3.util.equals(CloseSessionResponse, a, b);
    }
}
